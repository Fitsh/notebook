## 初识go语言

### 优势

- 可以直接编译为机器码，不依赖其它库，glibc版本有一定的要求，部署就是扔一个文件上去就行
- 静态语言
- 语言层面支持并发，Go最大的特色
- 内置runtime,支持垃圾回收，
- 丰富的标准库，内置了大量的库
- 内嵌C支持，
- 跨平台编译，不包含cgo就可以
- 内置强大的工具，

### 适合做什么

- 服务器编程
- 分布时系统
- 网络编程
- 内存数据库
- 云平台

### 学习资料

- Go语言官网
- [go中文社区](https://studygolang.com/)  https://studygolang.com/
- [go中文在线文档](https://studygolang.com/pkgdoc) https://studygolang.com/pkgdoc

### go标准命令概述

Go语言中包含了大量用于处理Go语言代码的命令和工具。其中，go命令就是最常用的一个，它有许多子命令。这些子命令都拥有不同的功能，如下所示。

- build：用于编译给定的代码包或Go语言源码文件及其依赖包。
- clean：用于清除执行其他go命令后遗留的目录和文件。
- doc：用于执行godoc命令以打印指定代码包。
- env：用于打印Go语言环境信息。
- fix：用于执行go tool fix命令以修正给定代码包的源码文件中包含的过时语法和代码调用。
- fmt：用于执行gofmt命令以格式化给定代码包中的源码文件。
- get：用于下载和安装给定代码包及其依赖包(提前安装git或hg)。
- list：用于显示给定代码包的信息。
- run：用于编译并运行给定的命令源码文件。
- install：编译包文件并编译整个程序。
- test：用于测试给定的代码包。
- tool：用于运行Go语言的特殊工具。
- version：用于显示当前安装的Go语言的版本信息。

### 第一个Go程序

- ==go语言以包作为管理单位==
- ==每个文件必须先声明包==
- ==程序必须有一个main包==
- ==go有且只有一个入口函数，main==
- ==左括号必须与函数名同行==
- 注释// 和/* */
- ==go语句结尾没有分号==
- ==导入的包必须要使用，不然报错==
- println()会自动换行

liteIDE,直接图形化界面编译，一个文件夹的文件只能有一个main函数



go build  xxx.go  编译go代码，生成一个可执行程序

go run xxx.go  不生成可执行程序，直接运行

```go
package main
import "fmt"

func main() {
	fmt.Println("hello go")
}
```



## 基本类型

数据类型作用：告诉编译器应该以多大的内存来存储

### 命名

命名规范

- 字母、数字、下划线
- 不能以数字开头
- 名字不能是关键字
- 区分大小写

### 变量

#### 变量声明

- 声明格式 ： var 变量名 类型

- 变量声明了，必须要使用，不然报错

- 只是声明没有初始化的变量，默认值为0
- 同一个{}里，声明的变量名是唯一的，
- 可以同时声明多个变量
  - var b, c int

#### 变量初始化

变量声明时，同时赋值

var b int  = 10

#### 自动推导类型

自动推导类型,必须初始化，通过初始化的值确定类型(常用)

`c := 30 `

多重初始化

`a, b := 10, 20`

%T 打印变量所属的类型

`fmt.Printf(" c type is %T\n", c)`



**赋值和自动推导区别**

- 赋值， 赋值前， 必须先声明变量
- 自动推导类型，本质上是先声明变量，再赋值
- 赋值能使用n次
- 自动推导，同一变量名自动推导只能使用一次，用于初始化那一次
- 自动推导后赋值可以无限次

```go
package main
import "fmt"
func main() {
    //  赋值， 赋值前， 必须先声明变量
    // 赋值能使用n次
    var a int
    a = 10
    fmt.Println("a = ", a)
    
    //:= , 自动推导类型，本质上是先声明变量，再赋值
    // 自动推导，同一变量名只能使用一次，用于初始化那一次
    b := 20
    fmt.Println("b = ", b)
    //b := 30 //前面已经由一个变量b，不能在新建一个变量b(
    
    b = 30
    fmt.Printfln("b = ", b)
}
```

**Println和Printf区别**

- Println一段一段处理，自动加换行
- Printf 格式化输出

#### 多重赋值

```go
package main
import "fmt"

func main() {
    i, j := 10, 20
    i, j = j, i  // 交换两个变量
}
```

#### 匿名变量

`_`匿名变量，丢弃数据不处理

```go
package main
import "fmt"

// go函数可以返回多个值
func test()(a, b, c int) {
    return 1, 2, 3
}
func main() {
    i, j := 10, 20
    vat tmp int
    // _匿名变量，丢弃数据不处理,_匿名变量配合函数返回值使用才有优势
    tmp, _ = i, j
    fmt.Println("tmp = ", tmp)
    
    var c, d, e int 
    c, d, e = test() // return 1, 2, 3
    
    _, d, _  = test() //return 1, 2, 3 只想要2
    fmt.Printf("%d\n", d)
}
```

### 常量

`const a int = 10`

- 常量不允许修改
- `const b = 10`自动推导，不能使用:=

### 多个常量或变量定义（声明）

```go
package main
import "fmt"

func main() {
/*
    var (
        a int
        b float64
    )
    a, b = 10, 23.4
    
 */
    /*
    var (
    	a int = 10
        b float64 = 1.23
    )
    */
    // 自动推导类型
    var (
        a = 10
        b = 123.3
    )
    fmt.Println(a, b)
    
/*
    const (
    	i int = 10
        j float64 = 12.3
    )
*/
    // 自动推导类型
    const (
        i = 10
        j = 12.23
    )
    fmt.Println(i, j)
    
}
```

### iota枚举

-  iota 常量自动生成器， 每个一行，自动累加1
- iota 给常量赋值使用
-  iota 遇到const重置为0
- 多个常量同时定义时，可以只写一个iota
- 如果常量是同一行，值都一样

 ```go
package main

import "fmt"

func main() {
	// iota 常量自动生成器， 每个一行，自动累加1
	// iota 给常量赋值使用
	const (
		a = iota  // 0
		b = iota  // 1
		c = iota  // 2
	)
	fmt.Println(a, b, c)

	// iota 遇到const重置为0
	const d = iota
	fmt.Println(d)  // 0

	// 可以只写一个iota
	const (
		a1 = iota
		b1
		c1
	)
	fmt.Println(a1, b1, c1) // 0 1 2 
	
	// 如果是同一行，值都一样
	const (
		i = iota
		j1, j2, j3 = iota, iota, iota
		k = iota
	)
	fmt.Println(i, j1, j2, j3, k) // 0 1 1 1 2
}
 ```

### 基本数据类型

#### 分类

![](/media/fitsh/文档/notebook/技术/golang/golang语言基础/doc_pic/基本数据类型.jpg)

#### bool类型

声明 ` var a bool`

自动推导 `b := true`

默认值false

#### 整型

var a int

var b int32

c := 10

#### 浮点型

声明: var f1 float32

f1 = 2.14

自动推导类型

f2:=3.14    // f2推导出float64

float64储存小数比float32更准确

#### 字符类型

支持两种字符类型，一种是byte(实际上是uint8的别名)，代表utf-8字符串的单个字节的值，另一种是rune,代表单个unicode字符

```go
package main

import "fmt"

func main() {
	var ch byte // 声明字符类型
	ch = 97
	fmt.Println("ch = ", ch) // 97
	
	// 格式化输出，%c以字符方式打印，%d以整型方式打印
	fmt.Printf("%c, %d\n", ch, ch)

	ch = 'a'  // 字符 单引号
	fmt.Printf("%c, %d\n", ch, ch)

	// 大写转小写 小写转大写
	fmt.Printf("大写: %d 小写: %d 大写转小写 %c  小写转大写 %c\n", 'A', 'a', 'A'+32, 'a'-32)
}
```

#### 字符串类型

在Go语言中不倾向于使用单引号来表示字符串，请根据需要使用双引号或反引号。 

==**Go语言中的字符串字面量使用 双引号 或 反引号 来创建**==：  

- 双引号用来创建==**可解析的字符串字面量**==(支持转义，但不能用来引用多行)；

  ```go
  fmt.Println("How are you?")
  fmt.Println("Fine, thank you.And you?")
  fmt.Println("I'm fine too.")
  ```

- 反引号用来创建==**原生的字符串字面量**==，这些字符串可能由多行组成(不支持任何转义序列)，原生的字符串字面量多用于书写多行消息、HTML以及正则表达式。

  ```go
  fmt.Println(`
                  How are you?
                  Fine, thank you. And you?
                  I'm fine too.
          `)
  ```

```go
package main

import "fmt"

func main() {
	var str1 string  // 声明变量
	str1 = "abc"
	fmt.Println("str1 = ", str1)

	// 自动推导类型
	str2 := "mike"
	fmt.Printf("str2类型是%T\n", str2); //string

	// 内建函数， len()可以测字符串长度，有多少字符
	fmt.Println("len(str2)", len(str2))  // 4
    
    fmt.Printf("str2[1] = %c\n", str2[1])  // i
}

```

**字符和字符串区别**

```go
package main

import "fmt"

func main() {
	var ch byte
    var str string
    
    // 字符
    // 1、单引号
    // 2、字符， 往往都只有一个字符，转义字符除外'\n'
    ch = 'a'
    fmt.Println("ch = ", ch)
    
    // 字符串
    // 1、双引号
    // 2、字符串由一个或多个字符组成
    // 3、字符串都是隐藏了一个结束符'\0'
    str = 'a' // 由'a'和'\0'组成了一个字符串
    fmt.Println("str = ", str)
    
    str = "hello go"
    
    // str[1] = 'c'; // 报错，不能改变字符串中的某个字符
    // 只想操作字符串的某个字符，从0开始操作
    fmt.Printf("str[0] = %c, str[1] = %c\n", str[0], str[1])
}
```

#### 复数类型

```go
package main

import "fmt"

func main() {
	var t complex128 //声明
	t = 2.1 + 3.12i
	fmt.Println("t = ", t)
	
	// 自动推导类型
	t2 := 3.3 + 4.4i
	fmt.Printf("t2 type is %T\n", t2)

	// 通过内建函数区实部和虚部
	fmt.Println("read(t2) = ", real(t2), "imag(t2)", imag(t2))
}
```

### fmt包的格式化输出输入

#### 格式化说明

通用：

```go
%v	值的默认格式表示
%+v	类似%v，但输出结构体时会添加字段名
%#v	值的Go语法表示
%T	值的类型的Go语法表示
%%	百分号
```

布尔值：

```go
%t	单词true或false
```

整数：

```
%b	表示为二进制
%c	该值对应的unicode码值
%d	表示为十进制
%o	表示为八进制
%q	该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示
%x	表示为十六进制，使用a-f
%X	表示为十六进制，使用A-F
%U	表示为Unicode格式：U+1234，等价于"U+%04X"
```

浮点数与复数的两个组分：

```
%b	无小数部分、二进制指数的科学计数法，如-123456p-78；参见strconv.FormatFloat
%e	科学计数法，如-1234.456e+78
%E	科学计数法，如-1234.456E+78
%f	有小数部分但无指数部分，如123.456
%F	等价于%f
%g	根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）
%G	根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）
```

字符串和[]byte：

```
%s	直接输出字符串或者[]byte
%q	该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示
%x	每个字节用两字符十六进制数表示（使用a-f）
%X	每个字节用两字符十六进制数表示（使用A-F）    
```

指针：

```
%p	表示为十六进制，并加上前导的0x    
```

没有%u。整数如果是无符号类型自然输出也是无符号的。类似的，也没有必要指定操作数的尺寸（int8，int64）。

宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下：

```
%f:    默认宽度，默认精度
%9f    宽度9，默认精度
%.2f   默认宽度，精度2
%9.2f  宽度9，精度2
%9.f   宽度9，精度0    
```

#### 格式化输出

#### 格式化输入

fmt.Scanf()

fmt.Scan()

```go
package main

import "fmt"

func main() {
    var a int
	// 阻塞等待用户的输入
    fmt.Scanf("%d", &a)
	fmt.Println(a)
	
	// 阻塞等待用户的输入
    fmt.Scan(&a) // 自动匹配
	fmt.Println(a)
}
```

### 类型转换

go语言不允许隐式转换，所有类型转换必须显式声明，而且只能发生在相互兼容的类型之间

```go
package main

import "fmt"

func main() {

	// 这种不能转换的类型，叫不兼容类型
	var flag bool
	flag = true
	fmt.Printf("flag = %t\n", flag)

	// bool 类型不能转为int
	// fmt.Printf("flag = %d\n", int(flag))

	// 0就是假，非0就是真
	// 整型也不能转换为bool
	// flag = bool(1)

	var ch byte
	ch = 'a' // 字符本质上就是整型
	var t int
	t = int(ch) // 类型转换，把ch的值取出来后，转成int再给t赋值
	fmt.Println("t = ", t);
}
```

### 类型别名

```go
type bigint int64  //int64 改名为bigint
var x bigint  = 100

type (
	myint int  // int改名为myint
    mystr string // string改名为mystr
)
```

## 运算符

### 算术运算符

`+` `-` `*` `/`  `%` 

`++`只有后自增，没有前自增  a = 0;  a++

`--`只有后自减，没有前自减  a = 2; a-- 	

### 关系运算符

` ==   !=     <     >    <=    >=`

### 逻辑运算符

`!      &&  		|| `

### 位运算符

` &			|  		^			<<			>>`

<<   乘2

`>>`除2

### 赋值运算符

`=	  +=		-=		*=		/=		%=`

`<<=		>>=		&=		^=		|=		`

```go
a := 10
a *= a + 2  // a = a * (a+2)    a = 120
```



### 其它运算符

& 取地址

`*`取值运算符

### 运算符优先级

1、 运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。

2、只有单目运算符、赋值运算符是从右向左运算的。

3、大致的顺序整理（优先级高到低） 
括号, 自增和自减. 
单目运算符 
算术运算符 
移位运算 
关系运算符 
位运算符 
逻辑运算符 
赋值运算符 
逗号

![](/media/fitsh/文档/notebook/技术/golang/golang语言基础/doc_pic/运算符优先级.png)

## 流程控制

### 选择结构

#### if语句

```go
var a int  = 3
if a == 3 { //条件表达式没有括号
    
}

// 只支持一个初始化表达式，初始化字句与表达式之间需要分号分割
if b := 3; b == 3 { 
    
}

if a:= 3; a == 4 {
    
} else {  // 左大括号必须与条件语句或else在同一行
    
}

if a == 10 {
    
}else if a > 10 {
    
} else {
    
}

if a:= 8; a == 10 {
    
} else if a > 10 {
    
} else if a < 10 {
    
} else {
    
}
```

#### switch语句

Go里面switch默认相当于每个case后面带有break,匹配成功后不会向下执行其它case，而是跳出整个switch

但是可以使用fallthrough强制执行后面的case代码

可以使用任何类型或表达式作为条件语句

```go
var score int = 90
switch score {
    case 90:
    	fmt.Println("90")
    	//fallthrough
    case 80:
    	fmt.Println("80")
    	//fallthrough
    case 70:
    	fmt.Println("70")
    	//fallthrough
    default:
    	fmt.Println("default")
}

switch s1 := 90; s1 {  // 初始化语句；条件
     case 90:
    	fmt.Println("90")
    case 80:
    	fmt.Println("80")
    case 70:
    	fmt.Println("70")
    	//fallthrough
    default:
    	fmt.Println("default")
}
s2 := 80
switch   {  // 可以没有条件
     case s2 >90:
    	fmt.Println("90")
    case s2 >80:
    	fmt.Println("80")
    case s2 >70:
    	fmt.Println("70")
    	//fallthrough
    default:
    	fmt.Println("default")
}
```



### 循环结构

#### for

```go
for 初始条件; 判断条件; 条件变化 {  

}

sum := 0
for i := 1; i <= 100; i++ {
    sum = sum + i
}

for {  // for后面可以不写任何东西，这个循环条件永远为真，死循环
    
}

```

#### range

关键字会返回两个值，第一个元素的数组下标，第二个是元素的值

```go
s := "abc"
for i := range s {  // 支持string、array、slice、map
    fmt.Print("%c\n", s[i])
}
for _, c := range s {   // 忽略index
    fmt.Printf("%c\n", c)
}

for i, c := range s {
    fmt.Printf("%d, %c\n", i, c)
}
```

### 跳转语句

#### break和continue

break可用于for、switch、select，而continue仅用于for循环

#### goto

用goto跳转到必须在当前函数内定义的标签

可以用在任何地方，反不能跨函数使用

```go
func hello () {
    
	goto End
    ...
End:
    ...
}
```



## 函数

### 定义格式

```go
func FuncName（/* 参数列表 */) (o1 type1, o2 type2/* 返回值类型 */) {
    // 函数体
    
    return v1, v2 // 返回多个值
}
```

函数定义说明

- func：函数由关键字func开始声明
- FuncName: 函数名称，根据约定，==函数名首字母小写即为private,大写即为public==
- 参数列表：函数可以由0个或多个参数，参数格式为：变量名 类型，如果由多个参数可以通过逗号分割，不支持默认参数
- 返回值类型
  - 上面声明了两个返回值变量o1和o2(命名返回参数)，这个不是必须，可以只有类型没有变量名
  - 如果只有一个返回值且不声明返回值变量，那么你可以省略，包括返回值的括号
  - 如果没有返回值，那么就直接省略最后的返回信息
  - 如果由返回值，必须在函数内部添加return语句

#### 无参无返回值

```go
func test() {
    
}
func main() {
    test()
}
```

#### 有参无返回值

##### 普通参数列表

```go
// 方式1
func Test01(v1 int, v2 int){
    
}

// 方式2
v1, v2 都是int类型
func Test02(v1, v2 int) {
    
}
func Test03(v1, v2 int, v3 float64, v4, v5 string) {
    
}
func main() {
    Test01(10, 20)
    Test02(11, 22)
}
```

##### 不定参数类型

不定参数是指函数传入的参数的个数为不定数量，为了做到这一点，首先需要把函数定义为接收不定参数类型

```go
// 形如...type格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数
func Test(args ...int) {
    len(args)      // 获取参数个数
    for _, n := range args { // 遍历参数列表
        
    }
}

func main() {
    Test()
    Test(1)
    Test(1, 2)
}
```

##### 不定参数传递

```go
func myfunc(tmp ...int){
    
}
func test(args ...int) {
    // 全部元素传递给myfunc
    myfunc(args...)
    
    // 只想传递后两个参数给另外一个函数使用
    myfunc(args[2:]...) //从args[2]开始（包括本身),把后面所有元素传递过去
    myfunc(args[:2]...) //args[0]~args[2]（不包括args[2]),传递过去
}
func main() {
    test(1, 2, 3, 4)
}
```

#### 无参有返回值

有返回值的函数，==必须有明确的终止语句==，否则会引发编译错误

##### 有一个返回值

```go
package main

import "fmt"

// 无参有返回值：只有一个返回值
// 有返回值的函数需要通过return中断函数，通过return返回
func myfunc01() int {
	return 666
}


// 给返回值起一个变量名，go推荐写法，看起来清晰一点
func myfunc02() (result int) {
	return 666
}
// 给返回值起一个变量名，go推荐写法
// 常用写法
func myfunc03() (result int) {
	result = 666
	return
}

func main() {
	// 无参有返回值函数的调用
	var a int
	a = myfunc01()
	fmt.Println(a)
	
	b := myfunc01()
	fmt.Println(b)

	c := myfunc02()
	fmt.Println(c)

	d := myfunc03()
	fmt.Println(d)
}

```

##### 多个返回值

```go
package main

import "fmt"

// 多个返回值
func myfunc01() (int , int , int) {
	return 1, 2,3
}

// go官方推荐
func myfunc02() (a int, b int, c int) {
	a, b, c = 111, 222, 333
	return
}
func myfunc03() (a , b, c int) {
	a, b, c = 111, 222, 333
	return
}
func main() {
	a, b, c := myfunc02()
	fmt.Println(a, b,c)
}
```



#### 有参有返回值

有返回值的函数，==必须有明确的终止语句==，否则会引发编译错误

### 自定义函数

### 递归函数

### 函数类型

函数也是一种数据类型，可以通过type来定义它，它的==类型是所有拥有相同参数，相同返回值的一种类型==

```go
package main
import "fmt"

func Add(a, b int) int {
	return a + b
}

func minus(a, b int) int {
	return a - b
}

// 函数也是一种数据类型，通过type给一个函数类型起名
// FuncType 它是一种函数类型
type FuncType func(int, int) int   // 没有函数名字，没有{}

func myfunc(a , b  int, f FuncType) int {
	return f(a, b)
}

func main() {
	var result int
	result = Add(1, 1)
	fmt.Println("result = ", result)

	// 声明一个函数类型的变量，变量名叫fTest
	var fTest FuncType
	fTest = Add			// 是变量就可以赋值
	result = fTest(10 , 20) // 等价于Add(10, 20)
	fmt.Println("result = ", result)

	fTest = minus			// 是变量就可以赋值
	result = fTest(10 , 20) // 等价于Add(10, 20)
	fmt.Println("result = ", result)

	result =myfunc(20, 30, Add)
	fmt.Println("result = ", result)
}
```

### 回调函数

函数由一个参数是函数类型，这个函数就是回调函数

多态，多种形态

```go
package main
import "fmt"

func Add(a, b int) int {
	return a + b
}

func minus(a, b int) int {
	return a - b
}

type FuncType func(int, int) int   

// 函数由一个参数是函数类型，这个函数就是回调函数
// 多态，多种形态,调用同一接口，可以实现不同的功能
func myfunc(a , b  int, f FuncType) int {
	return f(a, b)
}

func main() {
	var result int
	result = Add(1, 1)
	fmt.Println("result = ", result)

	// 声明一个函数类型的变量，变量名叫fTest
	var fTest FuncType
	fTest = Add			// 是变量就可以赋值
	result = fTest(10 , 20) // 等价于Add(10, 20)
	fmt.Println("result = ", result)

	fTest = minus			// 是变量就可以赋值
	result = fTest(10 , 20) // 等价于Add(10, 20)
	fmt.Println("result = ", result)

	result =myfunc(20, 30, Add)
	fmt.Println("result = ", result)
}
```



### 匿名函数与闭包

所谓闭包就是一个函数“捕获”了和它在同一作用域的其它常量和变量。这就意味着当闭包被调用的时候，不管在程序什么地方调用，闭包能够使用这些常量或者变量。==它不关心这些捕获了的变量和常量是否已经超出了作用域，所以只有闭包还在使用它，这些变量就还会存在。==

#### 匿名函数

```go
package main

import "fmt"

func main() {
	a := 10
	str := "mike"
	
	// 匿名函数,没有函数名字
	f1 := func() {
		fmt.Println("a = ", a)
		fmt.Println("str = ", str)
	}
	
	f1()

	// 给一个函数类型起别名
	type FuncType func() //函数没有参数，没有返回值
	var f2 FuncType
	f2 = f1
	f2()

	// 定义匿名函数，同时调用
	func() {
		fmt.Printf("a = %d, str = %s\n", a, str)
	}()   // 后面的()代表调用此匿名函数

	// 带参数的匿名函数
	f3 := func(i, j int) {
		fmt.Printf("i = %d, j = %d\n", i, j)
	}
	f3(1, 2)

	// 定义匿名函数，同时调用
	func(i, j int) {
		fmt.Printf("i = %d, j = %d\n", i, j)
	}(10, 20)


	// 	 匿名函数，由参有返回值
	x, y := func(i, j int) (max, min int) {
		if  i > j {
			max = i
			min = j
		} else {
			max = j
			min = i
		}
		return
	}(10, 20)
	fmt.Printf("x == %d, y == %d\n", x, y)
}
```

#### 闭包

所谓闭包就是一个函数“捕获”了和它在同一作用域的其它常量和变量。这就意味着当闭包被调用的时候，不管在程序什么地方调用，闭包能够使用这些常量或者变量。==它不关心这些捕获了的变量和常量是否已经超出了作用域，所以只有闭包还在使用它，这些变量就还会存在。==

##### 闭包捕获外部变量的特点

```go
package  main

import "fmt"

func main() {
	a := 10
	str := "mike"
	
	func() {
		// 闭包以引用方式捕获外部变量
		a = 666
		str = "go"
		fmt.Printf("内部：a = %d, str = %s\n", a, str) // a = 666, str = go
	}() //()代表直接调用
	fmt.Printf("外部：a = %d, str = %s\n", a, str) // a = 666 str = go
}
```

##### 闭包的特点

- 函数的返回值是一个匿名函数，返回一个函数类型
- 不关心这些捕获了的变量和常量是否已经超出了作用域，所以只有闭包还在使用它，这些变量就还会存在

```go
package  main

import "fmt"


// 函数的返回值是一个匿名函数，返回一个函数类型
// 不关心这些捕获了的变量和常量是否已经超出了作用域，所以只有闭包还在使用它，这些变量就还会存在
func test02() func() int {
	var x int // 没有初始化，值为0
	return func() int {
		x++
		return x *x
	}
}
func test01() int {
	// 函数调用时，x才分配内存，才初始化为0
	var x int // 没有初始化，值为0
	x++
	return x * x // 函数调用完毕，x自动释放
}

func main() {
	fmt.Println(test01()) //1
	fmt.Println(test01()) // 1
	fmt.Println(test01()) // 1

	// 返回值是一个匿名函数，返回一个函数类型,通过f来调用返回的匿名函数，f来调用闭包函数
	f := test02() 
	fmt.Println(f()) //1
	fmt.Println(f()) //4
	fmt.Println(f()) // 9
	fmt.Println(f()) // 16

}
```



### 延迟调用defer

#### defer的作用

关键字defer用于延迟一个函数或者方法（或者当初所创建的匿名函数）的执行。

注意：===defer语句只能出现在函数或者方法的内部==

defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。

```go
package main

import "fmt"

func main() {
	
	// defer 延迟调用，main函数结束前调用
	defer fmt.Println("bbbbbbbb")
	
	fmt.Println("aaaaaaa")
}

/*运行结果
aaaaaaa
bbbbbbbb
*/
```

#### 多个defer 执行顺序

如果一个函数中==有多个defer语句，他们会以LIFO(后进先出)的顺序执行，==哪怕某个函数或者某个延迟调用发生错误，这些调用依旧会执行

```go
package main

import "fmt"

func  test(x int) {
	fmt.Println(100/x)
}

func main() {
	
	defer fmt.Println("aaaaaaa")
	defer fmt.Println("bbbbbbb")
	test(0)
	defer fmt.Println("ccccccc")	
}
/*
bbbbbbb
aaaaaaa
panic: runtime error: integer divide by zero

goroutine 1 [running]:
main.test(...)
	/home/fitsh/Code/Go/practice/defer.go:6
main.main()
	/home/fitsh/Code/Go/practice/defer.go:13 +0x12a
exit status 2
*/
```

#### defer与匿名函数结合使用

```go
func main() {
    a, b := 10, 20
    defer func(x int) { // a以值传递给x
        fmt.Println("defer: ", x, b)  // b闭包引用
    }(a) //()代表调用此匿名函数，已经先传递参数，只是没有调用
    	
    a += 10
    b += 100
    fmt.Printf("a == %d, b== %d\n",a ,b)
}
/*
a == 20, b == 120
defer: 10 120
*/
```



### 获取命令行参数

```go
package main

import "fmt"
import "os"

func main() {
	// 接收用户传递的参数，都是以字符串方式传递
	list := os.Args

	n := len(list)
	fmt.Println("n == ", n)
	
	// xxx.exe a b
	for i := 0; i < n; i++ {
		fmt.Printf("list[%d] = %s\n", i, list[i])
	}
	// list[0] = xxx.exe
	// list[1] = a
	// list[2] = b
	
}
```

### 作用域

#### 局部作用域

定义在{}里面的变量就是局部变量，只能在{}内有效

执行到定义变量时才分配空间，离开作用域自动释放

```go
func main() {
	a := 100
    {
        i := 10
        fmt.Println("i = ", i)
    }
    // i = 100// 报错，未定义
    if flag:= 3; flag ==3 {
        
    }
    //flag = 4; // 报错，未定义
}
```



#### 全局作用域

定义在函数外的变量是全局变量

全局变量在任何地方都可以使用

==自动推导不能放到函数外==

#### 不同作用域，同名变量

```go
package main
import "fmt"
var a byte // 全局变量

func main() {
    var a int // 局部变量
    // 1、不同作用域，允许定义同名变量
    // 2、使用变量的原则，就近原则
    fmt.Printf("%T\n", a) // int
    {
        var a float32
        fmt.Printf("2: %T\n", a)// 2: float32
    }
    test()
}
func test(){
    fmt.Printf("3: %T\n", a)// 3: uint8,就是byte
}
```



## 工程管理

### 工作区

#### 工作区介绍

==Go代码必须放在工作区中==。工作区其实就是一个对应于特定工程的目录，它应包含3个子目录：src目录、pkg目录和bin目录。

1.  src目录：用于以代码包的形式组织并保存Go源码文件。（比如：.go .c .h .s等）
2.  pkg目录：用于存放经由go install命令构建安装后的代码包（包含Go库源码文件）的“.a”归档文件。
3.  bin目录：与pkg目录类似，在通过go install命令完成安装后，保存由Go命令源码文件生成的可执行文件。

​       目录src用于包含所有的源代码，是Go命令行工具一个强制的规则，而pkg和bin则无需手动创建，如果必要Go命令行工具在构建过程中会自动创建这些目录。

​       需要特别注意的是，只有当环境变量GOPATH中只包含一个工作区的目录路径时，go install命令才会把命令源码安装到当前工作区的bin目录下。==若环境变量GOPATH中包含多个工作区的目录路径，像这样执行go install命令就会失效，此时必须设置环境变量GOBIN。==

#### GOPATH设置

为了能够构建这个工程，需要先把所需工程的根目录加入到环境变量GOPATH中。否则，即使处于同一工作目录(工作区)，代码之间也无法通过绝对代码包路径完成调用。

在实际开发环境中，工作目录往往有多个。这些工作目录的目录路径都需要添加至GOPATH。当有多个目录时，请注意分隔符，多个目录的时候Windows是分号，[Linux](https://www.2cto.com/os/linux/)[系统](https://www.2cto.com/os/)是冒号，当有多个GOPATH时，默认会将go get的内容放在第一个目录下。

### 包

所有 Go 语言的程序都会组织成若干组文件，每组文件被称为一个包。这样每个包的代码都可以作为很小的复用单元，被其他项目引用。
一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径。

#### 自定义包

对于一个较大的应用程序，我们应该将它的功能性分隔成逻辑的单元，分别在不同的包里实现。我们创建的的自定义包最好放在GOPATH的src目录下（或者GOPATH src的某个子目录）。
 在Go语言中，代码包中的源码文件名可以是任意的。但是，这些任意名称的源码文件都必须以包声明语句作为文件中的第一行，每个包都对应一个独立的名字空间：
`package calc`
包中成员以名称⾸字母⼤⼩写决定访问权限：

1. public: ⾸字母 ⼤写，可被包外访问
2. private: ⾸字母 ⼩写，仅包内成员可以访问

**注意：**同一个目录下不能定义不同的package。

#### main包

在 Go 语言里，命名为 main 的包具有特殊的含义。 Go 语言的编译程序会试图把这种名字的包编译为二进制可执行文件。所有用 Go 语言编译的可执行程序都必须有一个名叫 main 的包。一个可执行程序有且仅有一个 main 包。
当编译器发现某个包的名字为 main 时，它一定也会发现名为 main()的函数，否则不会创建可执行文件。 main()函数是程序的入口，所以，如果没有这个函数，程序就没有办法开始执行。程序编译时，会使用声明 main 包的代码所在的目录的目录名作为二进制可执行文件的文件名。

#### main函数和init函数

### main函数

==main 函数只能在package main中。==

### init函数

==init 函数可在package main中，可在其他package中，可在同一个package中出现多次。==

golang里面有两个保留的函数：init函数（能够应用于所有的package）和main函数（只能应用于package main）。这两个函数在==定义时不能有任何的参数和返回值==。

虽然一个package里面可以写任意多个init函数，但这无论是对于可读性还是以后的可维护性来说，我们都强烈建议用户在一个package中每个文件只写一个init函数。

==go程序会自动调用init()和main()==，所以你不需要在任何地方调用这两个函数。每个package中的init函数都是可选的，但package main就必须包含一个main函数。

程序的初始化和执行都起始于main包。如果main包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），**最后执行main函数**。下图详细地解释了整个执行过程：

![](/media/fitsh/文档/notebook/技术/golang/golang语言基础/doc_pic/导包过程.png)

#### 导入包

==导入包，必须使用，否则编译不过==

```go
package main

// 方法1
/*
import "fmt"
import "os"
*/

// 方法2
import (
	"fmt"
    "os"
)

func main() {
    fmt.Println("this is a test")
    fmt.Println("os.Args = ", os.Args)
}

```



##### 点操作

调用函数，无需通过包名

```go
package main
 
import . "fmt" //调用函数，无需通过包名
import . "os"
 
//容易导致变量重名操作
func main() {
    Println("this is a test")
    Println("os.Args = ", Args)
}
```



##### 别名操作

```go
package main
 
//给包取别名
import io "fmt"
 
func main() {
    io.Println("this is a test")
}
```



##### _操作, 忽略此包

有时，用户可能需要导入一个包，但是不需要引用这个包的标识符。在这种情况，可以使用空白标识符_来重命名这个导入：
_操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数。

```go
package main
 
//忽略此包
import _ "fmt"
 
func main() {
 
}
```



### 测试案例

#### go  install使用

设置GOPATH环境变量

设置环境变量GOBIN：工程目录绝对路径\bin

cd src

go install

### 总结

- 分文件编程（多个源文件），必须放在src目录下

- 设置GOPATH环境变量
- 同一个目录，包名必须一样，不同目录，包名不一样
- go env 查看go相关的环境路径
- 同一个目录，调用别的文件的函数，直接调用即可，无需包名引用
- 调用不同包里的函数，格式：报名.函数名()
- 调用别的包的函数，这个包函数名字如果首字母小写，无法让别人访问，要想让别人访问，首字母必须大写



## 复合类型

### 分类

| 类型    | 名称   | 长度 | 默认值 | 说明     |
| ------- | ------ | ---- | ------ | -------- |
| pointer | 指针   |      | nil    |          |
| array   | 数组   |      | 0      |          |
| slice   | 切片   |      | nil    | 引用类型 |
| map     | 字典   |      | nil    | 引用类型 |
| struct  | 结构体 |      |        |          |

### 指针

​       指针是一个代表着某个内存地址的值。这个内存地址往往是在内存中存储的另一个变量的值的起始位置。Go语言对指针的支持介于Java语言和C/C++语言之间，它既没有想Java语言那样取消了代码对指针的直接操作的能力，也避免了C/C++语言中由于对指针的滥用而造成的安全和可靠性问题。

#### 基本操作

Go语言虽然保留了指针，但与其它编程语言不同的是：

1. 默认值 nil，没有 NULL 常量
2. 操作符 "&" 取变量地址， "*" 通过指针访问目标对象
3. 不支持指针运算，不支持 "->" 运算符，直接⽤ "." 访问目标成员

```go
package main

import "fmt"

func main() {
	var a int = 10
	// 每个变量有2层含义：变量的地址，变量的内存
	fmt.Printf("a = %d\n", a) // 变量的内存
	fmt.Printf("&a = %v\n", &a) // 变量的地址

	// 保存某个变量的地址，需要指针类型 *int 保存int地址， **int保存*int地址
	// 声明（定义），定义只是特殊的声明
	// 定义一个指针p，类型 *int
	var p *int 
	p = &a // 指针变量指向谁，就把谁的地址赋值给指针变量
	fmt.Printf("p = %v, &a = %v\n", p, &a)
	
	*p = 666   // *p操作的不是p的内存，是p所指向的内存(就是a)

	fmt.Printf("*p = %v, a = %v\n", *p, a)
}
```

不要操作没有合法指向的内存

```go
package main //必须有个main包
 
import "fmt"
 
func main() {
    //没有指向内存
    var p *int
    p = nil //nil指的是空
    fmt.Println("p = ", p)
 
    //*p = 666 //err, 不能直接*p赋值，因为p没有合法指向
 
    var a int
    p = &a //p指向a
    *p = 666
    fmt.Println("a = ", a)
 
}

```

#### new函数

  表达式new(T)将创建一个T类型的匿名变量，所做的是为T类型的新值分配并清零一块内存空间，然后将这块内存空间的地址作为结果返回，而这个结果就是指向这个新的T类型值的指针值，返回的指针类型为*T。

​         我们只需使用new()函数，无需担心其内存的生命周期或怎样将其删除，因为Go语言的内存管理系统会帮我们打理一切

```go
package main

import "fmt"

func main() {
	// a:= 10 // 整型变量a

	var p *int
	// 指向一个合法内存
	// p = &a

	// p是*int，指向int类型

	p = new(int)
	fmt.Println("*p  = ", *p)
	q :=new(int)  // 自动推导类型
	*q = 777
	fmt.Println("*q = ", *q)
}
```

#### 指针做函数参数

```go

package main //必须有个main包
 
import "fmt"
 
func swap(a, b int) {
    a, b = b, a
    fmt.Printf("swap: a = %d, b = %d\n", a, b)
}
 
func main() {
    a, b := 10, 20
 
    //通过一个函数交换a和b的内容
    swap(a, b) //变量本身传递，值传递（站在变量角度）
    fmt.Printf("main: a = %d, b = %d\n", a, b)
}
```

### 数组

#### 概述

==数组长度必须是常量，且是类型的组成部分，[2]int和[3]int是不同类型==

```go
var n int = 10
var a [n]int // err
var a [10]int
```

#### 操作数组

```go
var a [10]int
a[0] = 1
i := 1
a[i] = 2 // a[1] = 2

// 赋值，每个元素
for i := 0; i < len(a); i++ {
    a[i] = i + 1
}
// 打印
for i, data := range a {
    fmt.Printf("%d, %v\n", i, data)
}

// 初始化
// 声明定义同时赋值，叫初始化
var b [5]int = [5]int{1, 2, 3, 4, 5}

fmt.Println("a = ", a)

b := [5]int{1, 2, 3, 4, 5}
fmt.Println(b) 

//部分初始化，没有初始化的元素，自动赋值为0
c :=[5]int{1, 2, 3}
fmt.Println("c = ", c)

// 指定某个元素初始化
d := [5]int{2:10, 4:20}
fmt.Println("d = ", d)


// 二维数组
var a [3][4]int
 k := 0
    for i := 0; i < 3; i++ {
        for j := 0; j < 4; j++ {
            k++
            a[i][j] = k
            fmt.Printf("a[%d][%d] = %d, ", i, j, a[i][j])
        }
        fmt.Printf("\n")
    }

 //有3个元素，每个元素又是一维数组[4]int
    b := [3][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}}
    fmt.Println("b = ", b)
 
    //部分初始化，没有初始化的值为0
    c := [3][4]int{{1, 2, 3}, {5, 6, 7, 8}, {9, 10}}
    fmt.Println("c = ", c)
 
    d := [3][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}}
    fmt.Println("d = ", d)
 
    e := [3][4]int{1: {5, 6, 7, 8}}
    fmt.Println("e = ", e)



```

```go
// 支持比较，只支持 == 或 ！=， 比较是不是每一个元素都一样，2个数组比较，数组类型要一样
a := [5]int{1, 2, 3, 4, 5}
b := [5]int{1, 2, 3, 4 ,5}
c := [5]int{1, 2, 3}
fmt.Println("a == b", a==b)
fmt.Println("a == c", a== c)
// 同类型的数组可以赋值
var d [5]int
d = a
fmt.Println("d = ", d)
```

#### 随机数的使用

```go
package "fmt"
import "fmt"
import "math/rand"

func main() {
    // 设置种子，只需一次
    rand.Seed(666) 
    rand.Seed(time.Now().Unixnano()) //以当前系统时间为种子参数
    for i := 0; i < 5; i++ {
        // 产生随机数
        fmt.Println("rand = ", rand.Int())
         fmt.Println("rand = ", rand.Intn(100)) //限制在100以内的数
    }
}
```





#### 函数间传递数组

- 数组做函数参数是值传递

```go
package main
import "fmt"

// 数组作函数参数，它是值拷贝
// 实参数祖的每个元素给行参拷贝一份
//行参数组是实参数组的复制品
fun modify(a [5]int) {
    a[0] = 666
    fmt.Println("modify: a   = ", a)
}
func main() {
    a := [5]int{1, 2, 3, 4, 5} //初始化
    modify(a)
    fmt.Println("main: a = ", a)
}
```

- 数组指针作函数参数

  ```go
  package main
  import "fmt"
  
  // p指向实参数组a，它指向数组，它是数组指针
  //*p代表指针所指向的内存，就是实参a
  fun modify(p *[5]int) {
      (*p)[0] = 666
      fmt.Println("modify: *p   = ", *p)
  }
  func main() {
      a := [5]int{1, 2, 3, 4, 5} //初始化
      modify(&a)
      fmt.Println("main: a = ", a)
  }
  ```

### 切片(slice)

#### 概述

切片并不是数组或数组指针，==它通过内部指针和属性引用数组片段，以实现变长方案。==

切片并不是数组或指针，==是一个引用类型,slice总是指向一个底层array==，slice的声明也可以像array一样，只是==不需要长度==。

![](/media/fitsh/63D6-6604/notebook/技术/golang/golang语言基础/doc_pic/切片与数组.png)

[low:high:max]

low: 下标的起点

high：下标的终点（不包括此下标），[a[low], a[high])左闭右开

len = high- low   长度

cap = max - low  容量

#### 切片与数组区别

```go
package main	
import fmt 
func main() {
    // 切片与数组的区别
  	// 数组的长度是一个固定的常量，数组不能修改长度，len和cap永远都是5
    a := [5]int{}
    fmt.Println("len = %d, cap = %d\n", len(a), cap(a))
    
    // 切片， [] 里面为空，或者为...,切片长度或容量可以不固定 
    s := []int{}
    fmt.Println("len = %d, cap = %d\n", len(a), cap(a))
    
    s = append(s, 11) // 给切片末尾追加一个成员
    fmt.Println("len = %d, cap = %d\n", len(s), cap(s)) 
     
}
```

#### 创建方式

```go
package main	
import fmt 
func main() {
    // 自动推导类型, 同时初始化
    s1 := []int{1, 2, 3, 4}
    fmt.Println("s1 = ", s1)
    
    // 借助make函数，格式make（切片类型，长度， 容量)
    s2 := make([]int, 5, 10)
    fmt.Println("len = %d, cap = %d\n", len(s2), cap(s2)) 
    
    // 没有指定容量，容量和长度一样
    s3:= make([]int, 5)
    fmt.Println("len = %d, cap = %d\n", len(s3), cap(s3)) 
}
```

#### 切片截取

| **操作**                | **含义**                                                     |
| ----------------------- | ------------------------------------------------------------ |
| **s[n]**                | 切片s中索引位置为n的项                                       |
| **s[:]**                | 从切片s的索引位置0到len(s)-1处所获得的切片                   |
| **s[low:]**             | 从切片s的索引位置low到len(s)-1处所获得的切片                 |
| **s[:high]**            | 从切片s的索引位置0到high处所获得的切片，len=high             |
| **s[low:high]**         | 从切片s的索引位置low到high处所获得的切片，len=high-low       |
| **s[low : high : max]** | 从切片s的索引位置low到high处所获得的切片，len=high-low，cap=max-low |
| **len(s)**              | 切片s的长度，总是<=cap(s)                                    |
| **cap(s)**              | 切片s的容量，总是>=len(s)                                    |

```go
package main //必须有个main包

import "fmt"

func main() {
	array := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	//[low:high:max] 取下标从low开始的元素， len=high-low, cap=max-low
	s1 := array[:] //[0:len(array):len(array)] 不指定容量和长度一样
	fmt.Println("s1 = ", s1)
	fmt.Printf("len = %d, cap = %d\n", len(s1), cap(s1))

	//操作某个元素，和数组操作方式一样
	data := array[1]
	fmt.Println("data = ", data)

	s2 := array[3:6:7] //a[3], a[4], a[5]   len = 6-3=3    cap = 7-3=4
	fmt.Println("s2 = ", s2)
	fmt.Printf("len = %d, cap = %d\n", len(s2), cap(s2))

	s3 := array[:6] //从0开始，去6个元素，容量也是6， 常用
	fmt.Println("s3 = ", s3)
	fmt.Printf("len = %d, cap = %d\n", len(s3), cap(s3))

	s4 := array[3:] //从下标为3开始，到结尾
	fmt.Println("s4 = ", s4)  //[3 4 5 6 7 8 9]
	fmt.Printf("len = %d, cap = %d\n", len(s4), cap(s4))
}
执行结果：
s1 = [0 1 2 3 4 5 6 7 8 9]
len = 10, cap = 10
data = 1
s2 = [3 4 5]
len = 3, cap = 4
s3 = [0 1 2 3 4 5]
len = 6, cap = 10
s4 = [3 4 5 6 7 8 9]
len = 7, cap = 7
```

#### 切片与底层数组之间的关系

```go
package main //必须有个main包
 
import "fmt"
 
func main() {
    a := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
 
    //新切片
    s1 := a[2:5] //从a[2]开始，取3个元素
    s1[1] = 666
    fmt.Println("s1 = ", s1) //[2 3 4]
    fmt.Println("a = ", a)   //[2 666 4]
 
    //另外新切片
    s2 := s1[2:7]
    s2[2] = 777
    fmt.Println("s2 = ", s2) //[4 5 777 7 8]
    fmt.Println("a = ", a)   //[0 1 2 666 4 5 777 7 8 9]
}
执行结果：
s1 =  [2 666 4]
a =  [0 1 2 666 4 5 6 7 8 9]
s2 =  [4 5 777 7 8]
a =  [0 1 2 666 4 5 777 7 8 9]
```

### 内建函数

#### append函数

append函数向slice尾部添加数据，返回新的slice数据

```go
package main //必须有个main包

import "fmt"

func main() {
    s1 := []int{}
    fmt.Printf("len = %d, cap = %d\n", len(s1), cap(s1))
    fmt.Println("s1 = ", s1)
 
    //在原切片的末尾添加元素
    s1 = append(s1, 1)
    s1 = append(s1, 2)
    s1 = append(s1, 3)
    fmt.Printf("len = %d, cap = %d\n", len(s1), cap(s1))
    fmt.Println("s1 = ", s1)
 
    s2 := []int{1, 2, 3}
    fmt.Println("s2 = ", s2)
    s2 = append(s2, 5)
    s2 = append(s2, 5)
    s2 = append(s2, 5)
    fmt.Println("s2 = ", s2)
}
#执行结果：

len = 0, cap = 0
s1 =  []
len = 3, cap = 4
s1 =  [1 2 3]
 
s2 =  [1 2 3]
s2 =  [1 2 3 5 5 5]
```

**append扩容特点**:如果超过原来的容量，通常以2倍容量扩容,重新分配新数组，并复制原来的数组

```go
package main //必须有个main包
 
import "fmt"
 
func main() {
    //如果超过原来的容量，通常以2倍容量扩容
    s := make([]int, 0, 1) //长度为0，容量为1
    oldCap := cap(s)
    for i := 0; i < 20; i++ {
        s = append(s, i)
        if newCap := cap(s); oldCap < newCap {
            fmt.Printf("cap: %d ===> %d\n", oldCap, newCap)
 
            oldCap = newCap
        }
    }
 
}
执行结果：  
cap: 1 ===> 2
cap: 2 ===> 4
cap: 4 ===> 8
cap: 8 ===> 16
cap: 16 ===> 32
```

#### copy函数

```go
package main //必须有个main包
 
import "fmt"
 
func main() {
    srcSlice := []int{1, 2}  //源
    dstSlice := []int{6, 6, 6, 6, 6}  //目的
     
    //源替换目的位置
    copy(dstSlice, srcSlice)
    fmt.Println("dst = ", dstSlice)
}
执行结果：
dst =  [1 2 6 6 6]
```

#### 切片做函数参数

```go
package main //必须有个main包
 
import "fmt"
import "math/rand"
import "time"
 
func InitData(s []int) {
    //设置种子
    rand.Seed(time.Now().UnixNano())
 
    for i := 0; i < len(s); i++ {
        s[i] = rand.Intn(100) //100以内的随机数
    }
}
 
//冒泡排序
func BubbleSort(s []int) {
    n := len(s)
 
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-1-i; j++ {
            if s[j] > s[j+1] {
                s[j], s[j+1] = s[j+1], s[j]
            }
        }
    }
}
 
func main() {
    n := 10
 
    //创建一个切片，len为n
    s := make([]int, n)
 
    InitData(s) //初始化数组
    fmt.Println("排序前： ", s)
 
    BubbleSort(s) //冒泡排序
    fmt.Println("排序后： ", s)
}
执行结果：
排序前：  [91 20 62 5 47 51 97 54 72 18]
排序后：  [5 18 20 47 51 54 62 72 91 97]
```

### 猜数字游戏

```go
package main //必须有个main包
 
import "fmt"
import "math/rand"
import "time"
 
func CreatNum(p *int) {
    //设置种子
    rand.Seed(time.Now().UnixNano())
 
    var num int
    for {
        num = rand.Intn(10000) //一定是4位数
        if num >= 1000 {
            break
        }
    }
 
    //fmt.Println("num = ", num)
 
    *p = num
 
}
 
func GetNum(s []int, num int) {
    s[0] = num / 1000       //取千位
    s[1] = num % 1000 / 100 //取百位
    s[2] = num % 100 / 10   //取百位
    s[3] = num % 10         //取个位
}
 
func OnGame(randSlice []int) {
    var num int
    keySlice := make([]int, 4)
 
    for {
        for {
            fmt.Printf("请输入一个4位数：")
            fmt.Scan(&num)
 
            // 999 < num < 10000
            if 999 < num && num < 10000 {
                break
            }
 
            fmt.Println("请输入的数不符合要求")
        }
        //fmt.Println("num = ", num)
        GetNum(keySlice, num)
        //fmt.Println("keySlice = ", keySlice)
 
        n := 0
        for i := 0; i < 4; i++ {
            if keySlice[i] > randSlice[i] {
                fmt.Printf("第%d位大了一点\n", i+1)
            } else if keySlice[i] < randSlice[i] {
                fmt.Printf("第%d位小了一点\n", i+1)
            } else {
                fmt.Printf("第%d位猜对了\n", i+1)
                n++
            }
        }
 
        if n == 4 { //4位都猜对了
            fmt.Println("全部猜对!!!")
            break //跳出循环
        }
    }
}
 
func main() {
    var randNum int
 
    //产生一个4位的随机数
    CreatNum(&randNum)
    //fmt.Println("randNum: ", randNum)
 
    randSlice := make([]int, 4)
    //保存这个4位数的每一位
    GetNum(randSlice, randNum)
    //fmt.Println("randSlice = ", randSlice)
 
    /*
        n1 := 1234 / 1000 //取商
        //(1234 % 1000) //取余数，结果为234   234/100取商得到2
        n2 := 1234 % 1000 / 100
        fmt.Println("n1 = ", n1)
        fmt.Println("n2 = ", n2)
    */
 
    OnGame(randSlice) //游戏
 
}
执行结果：
请输入一个4位数：7146
第1位猜对了
第2位猜对了
第3位大了一点
第4位猜对了
 
请输入一个4位数：7116
第1位猜对了
第2位猜对了
第3位猜对了
第4位猜对了
全部猜对!!!
```

### map

Go语言中的map(映射、字典)是一种内置的数据结构，它是一个无序的key—value对的集合，比如以身份证号作为唯一键来标识一个人的信息。

![](E:\notebook\技术\golang\golang语言基础\doc_pic\map.png)

map格式为：

```go
`map``[keyType]valueType`
```

在一个map里所有的键都是唯一的，而且必须是支持==和!=操作符的类型，切片、函数以及包含切片的结构类型这些类型由于具有引用语义，不能作为映射的键，使用这些类型会造成编译错误：

```go
`dict := ``map``[ []string ]int{} ``//err, invalid map key type []string`
```

map值可以是任意类型，没有限制。map里所有键的数据类型必须是相同的，值也必须相同，但键和值的数据类型可以不相同。

 **注意**：map是==无序==的，我们无法决定它的返回顺序，所以，每次打印结果的顺利有可能不同。

```go
package main //必须有个main包
 
import "fmt"
 
func main() {
    //定义一个变量， 类型为map[int]string
    var m1 map[int]string
    fmt.Println("m1 = ", m1)
    //对于map只有len，没有cap
    fmt.Println("len = ", len(m1))
 
    //可以通过make创建
    m2 := make(map[int]string)
    fmt.Println("m2 = ", m2)
    fmt.Println("len = ", len(m2))
 
    //可以通过make创建，可以指定长度，只是指定了容量，但是里面却是一个数据也没有
    m3 := make(map[int]string, 2) //指定容量为2（0 1 2）,会自动扩冲
    m3[1] = "mike"                //元素的操作
    m3[2] = "go"
    m3[3] = "c++"
 
    fmt.Println("m3 = ", m3)
    fmt.Println("len = ", len(m3))
 
    //常用方法，推荐使用
    //初始化
    //键值是唯一的
    m4 := map[int]string{1: "mike", 2: "go", 3: "c++"}
    fmt.Println("m4 = ", m4)
 
}
```

#### map赋值

```go
package main //必须有个main包
 
import "fmt"
 
func main() {
    m1 := map[int]string{1: "mike", 2: "yoyo"}
    //赋值，如果已经存在的key值，修改内容
    fmt.Println("m1 = ", m1)
    m1[1] = "c++"
    m1[3] = "go" //追加，map底层自动扩容，和append类似
    fmt.Println("m1 = ", m1)
}
执行结果：
m1 =  map[2:yoyo 1:mike]
m1 =  map[1:c++ 2:yoyo 3:go]
```

#### map遍历

```go
package main //必须有个main包
 
import "fmt"
 
func main() {
    m := map[int]string{1: "mike", 2: "yoyo", 3: "go"}
 
    //第一个返回值为key, 第二个返回值为value, 遍历结果是无序的
    for key, value := range m {
        fmt.Printf("%d =======> %s\n", key, value)
    }
}
执行结果:
3 =======> go
1 =======> mike
2 =======> yoyo
```

#### map判断一个key值是否存在

```go
package main //必须有个main包
 
import "fmt"
 
func main() {
    m := map[int]string{1: "mike", 2: "yoyo", 3: "go"}
 
    //第一个返回值为key, 第二个返回值为value, 遍历结果是无序的
    for key, value := range m {
        fmt.Printf("%d =======> %s\n", key, value)
    }
 
    //如何判断一个key值是否存在
    //第一个返回值为key所对应的value, 第二个返回值为key是否存在的条件，存在ok为true
    //value, ok := m[1]   //已经存在的value
    value, ok := m[0] //key不存在
    if ok == true {
        fmt.Println("m[1] = ", value)
    } else {
        fmt.Println("key不存在")
    }
}
执行结果：
1 =======> mike
2 =======> yoyo
3 =======> go
key不存在
```

#### map删除

```go
package main //必须有个main包
 
import "fmt"
 
func main() {
    m := map[int]string{1: "mike", 2: "yoyo", 3: "go"}
    fmt.Println("m = ", m)
 
    delete(m, 1) //删除key为1的内容
    fmt.Println("m = ", m)
}
执行结果：
m =  map[2:yoyo 3:go 1:mike]
m =  map[2:yoyo 3:go]
```

#### map做函数参数

map做函数参数其实是引用的

```go
package main //必须有个main包
 
import "fmt"
 
//{1: "mike", 2: "yoyo", 3: "go"} 
func test(m map[int]string) {
    delete(m, 1)   //删除1个
 
func main() {
    m := map[int]string{1: "mike", 2: "yoyo", 3: "go"}
    fmt.Println("m = ", m)
 
    test(m) //在函数内部删除某个key
 
    fmt.Println("m = ", m)
}
执行结果：
m =  map[1:mike 2:yoyo 3:go]
m =  map[2:yoyo 3:go]
```

### 结构体

有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。

![](E:\notebook\技术\golang\golang语言基础\doc_pic\结构体.png)

结构体是一种聚合的数据类型，它是由一系列具有相同类型或不同类型的数据构成的数据集合。每个数据称为结构体的成员。

#### 结构体初始化

##### 普通变量初始化

```go
package main //必须有个main包
 
import "fmt"
 
//定义一个结构体类型
type Student struct {
    id   int
    name string
    sex  byte //字符类型
    age  int
    addr string
}
 
func main() {
    //顺序初始化，每个成员必须初始化
    var s1 Student = Student{1, "mike", 'm', 18, "bj"}
    fmt.Println("s1 = ", s1)
 
    //指定成员初始化，没有初始化的成员，自动赋值为0
    s2 := Student{name: "mike", addr: "bj"}
    fmt.Println("s2 = ", s2)
}
执行结果：
s1 =  {1 mike 109 18 bj}
s2 =  {0 mike 0 0 bj}
```

##### 结构体指针变量初始化

```go
package main //必须有个main包
 
import "fmt"
 
//定义一个结构体类型
type Student struct {
    id   int
    name string
    sex  byte //字符类型
    age  int
    addr string
}
 
func main() {
    //顺序初始化，每个成员必须初始化, 别忘了& ，&取地址
    var p1 *Student = &Student{1, "mike", 'm', 18, "bj"}
    fmt.Println("p1 = ", p1)
 
    //指定成员初始化，没有初始化的成员，自动赋值为0
    p2 := &Student{name: "mike", addr: "bj"}
    fmt.Printf("p2 type is %T\n", p2) //main函数结构体
    fmt.Println("p2 = ", p2)
}　
执行结果：
p1 = &{1 mike 109 18 bj}
 
p2 type is *main.Student
 
p2 = &{0 mike 0 0 bj}
```

#### 结构体成员的使用

##### 普通变量使用

```go
package main //必须有个main包
 
import "fmt"
 
//定义一个结构体类型
type Student struct {
    id   int
    name string
    sex  byte //字符类型
    age  int
    addr string
}
 
func main() {
    //定义一个结构体普通变量
    var s Student
 
    //操作成员，需要使用点(.)运算符
    s.id = 1
    s.name = "mike"
    s.sex = 'm' //字符
    s.age = 18
    s.addr = "bj"
    fmt.Println("s = ", s)
}
执行结果：
s =  {1 mike 109 18 bj}
```

##### 使用指针变量

```go
package main //必须有个main包
 
import "fmt"
 
//定义一个结构体类型
type Student struct {
    id   int
    name string
    sex  byte //字符类型
    age  int
    addr string
}
 
func main() {
    //1、指针有合法指向后，才操作成员
    //先定义一个普通结构体变量
    var s Student
    //在定义一个指针变量，保存s的地址
    var p1 *Student
    p1 = &s
 
    //通过指针操作成员  p1.id 和(*p1).id完全等价，只能使用.运算符
    p1.id = 1
    (*p1).name = "mike"
    p1.sex = 'm'
    p1.age = 18
    p1.ad dr = "bj"
    fmt.Println("p1 = ", p1)
 
    //2、通过new申请一个结构体
    p2 := new(Student)
    p2.id = 1
    p2.name = "mike"
    p2.sex = 'm'
    p2.age = 18
    p2.addr = "bj"
    fmt.Println("p2 = ", p2)
 
}
执行结果：
第一种方法：
p1 =  &{1 mike 109 18 bj}
 
第二种方法：
p2 =  &{1 mike 109 18 bj}
```

#### 结构体比较和赋值 （同类型的结构体可以相互赋值）

```go
package main //必须有个main包
 
import "fmt"
 
//定义一个结构体类型
type Student struct {
    id   int
    name string
    sex  byte //字符类型
    age  int
    addr string
}
 
func main() {
    s1 := Student{1, "mike", 'm', 18, "bj"}
    s2 := Student{1, "mike", 'm', 18, "bj"}
    s3 := Student{2, "mike", 'm', 18, "bj"}
    fmt.Println("s1 == s2 ", s1 == s2)
    fmt.Println("s1 == s3 ", s1 == s3)
 
    //同类型的2个结构体变量可以相互赋值
    var tmp Student
    tmp = s3
    fmt.Println("tmp = ", tmp)
 
}
#执行结果：
s1 == s2  true    //相等所以是true
s1 == s3  false   //不相等所以是false
tmp =  {2 mike 109 18 bj}  //赋值s3的结果，打印出来
```

#### 结构体做函数参数 值传递和地址传递

```go
package main //必须有个main包
import "fmt"
 
//定义一个结构体类型
type Student struct {
    id   int
    name string
    sex  byte //字符类型
    age  int
    addr string
}
 
func test01(s Student) {
    s.id = 666
    fmt.Println("test01: ", s)
}
 
func main() {
    s := Student{1, "mike", 'm', 18, "bj"}
 
    test01(s) //地址传递
    fmt.Println("main: ", s)
 
}
执行结果：
test01:  {666 mike 109 18 bj}
main:  {1 mike 109 18 bj}
```

```go
package main //必须有个main包
 
import "fmt"
 
//定义一个结构体类型
type Student struct {
    id   int
    name string
    sex  byte //字符类型
    age  int
    addr string
}
 
func test02(p *Student) {
    p.id = 666
}
 
func main() {
    s := Student{1, "mike", 'm', 18, "bj"}
 
    test02(&s) //地址传递（引用传递），形参可以改实参
    fmt.Println("main: ", s)
 
}
执行结果：
main:  {666 mike 109 18 bj}
```

#### [可见性规则验证]

- 如果想使用别的包的函数、结构体类型、络构体成员。
- 函数名、类型名，结构体成员变量名，==首字母必段大写==，可见。
- 如果首字母是小写，只能在同一个包里使用。

![](E:\notebook\技术\golang\golang语言基础\doc_pic\可见性.png)

```go
//vi test.go
package test
 
import "fmt"
 
//如果首字母是小写，只能在同一个包里使用
type stu struct {
    id int
}
 
type Stu struct {
    //id int //如果首字母是小写，只能在同一个包里使用
    Id int
}
 
//如果首字母是小写，只能在同一个包里使用
func myFunc() {
    fmt.Println("this is myFunc")
}
<br>//如果首字母是大写，可以在包外面使用
func MyFunc() {
    fmt.Println("this is MyFunc -=======")
}
//vi main.go
package main //必须有个main包
 
import "test"
import "fmt"
 
func main() {
    //包名.函数名
    test.MyFunc()
 
    //包名.结构体里类型名
    var s test.Stu
    s.Id = 666
    fmt.Println("s = ", s)
}
```



## 面向对象编程

### 面向对象编程

对于面向对象编程的支持Go 语言设计得非常简洁而优雅。因为， Go语言并没有沿袭传统面向对象编程中的诸多概念，比如继承(不支持继承，尽管匿名字段的内存布局和行为类似继承，但它并不是继承)、虚函数、构造函数和析构函数、隐藏的this指针等。

尽管Go语言中没有封装、继承、多态这些概念，但同样通过别的方式实现这些特性：

1. 封装：通过方法实现
2. 继承：通过匿名字段实现
3. 多态：通过接口实现

### 匿名组合

#### 匿名字段

```go
package main
 
import "fmt"
 
type Person struct {
    name string //名字
    sex  byte   //性别
    age  int    //年龄
}
 
type Student struct {
    Person //只有类型，没有名字，匿名字段，继承了Person的成员
    id     int
    addr   string
}
```



#### 匿名字段初始化

```go

package main
 
import "fmt"
 
type Person struct {
    name string //名字
    sex  byte   //性别
    age  int    //年龄
}
 
type Student struct {
    Person //只有类型，没有名字，匿名字段，继承了Person的成员
    id     int
    addr   string
}
 
func main() {
    //顺序初始化
    var s1 Student = Student{Person{"mike", 'm', 18}, 1, "bj"}
    fmt.Println("s1 = ", s1)
 
    //自动推导类型
    s2 := Student{Person{"mike", 'm', 18}, 1, "bj"}
    //fmt.Println("s2 = ", s2)
    //%+v, 显示更详细
    fmt.Printf("s2 = %+v\n", s2)
 
    //指定成员初始化，没有初始化的常用自动赋值为0
    s3 := Student{id: 1}
    fmt.Printf("s3 = %+v\n", s3)
 
    s4 := Student{Person: Person{name: "mike"}, id: 1}
    fmt.Printf("s4 = %+v\n", s4)
 
}
执行结果：
s1 =  {{mike 109 18} 1 bj}
s2 = {Person:{name:mike sex:109 age:18} id:1 addr:bj}
s3 = {Person:{name: sex:0 age:0} id:1 addr:}
s4 = {Person:{name:mike sex:0 age:0} id:1 addr:}
```

#### 成员操作

```go

package main
 
import "fmt"
 
type Person struct {
    name string //名字
    sex  byte   //性别, 字符类型
    age  int    //年龄
}
 
type Student struct {
    Person //只有类型，没有名字，匿名字段，继承了Person的成员
    id     int
    addr   string
}
 
func main() {
    s1 := Student{Person{"mike", 'm', 18}, 1, "bj"}
    s1.name = "yoyo"
    s1.sex = 'f'
    s1.age = 22
    s1.id = 666
    s1.addr = "sz"
 
    s1.Person = Person{"go", 'm', 18}
 
    fmt.Println(s1.name, s1.sex, s1.age, s1.id, s1.addr)
 
}
执行结果：
go 109 18 666 sz
```

#### 同名字段

```go

package main
 
import "fmt"
 
type Person struct {
    name string //名字
    sex  byte   //性别, 字符类型
    age  int    //年龄
}
 
type Student struct {
    Person //只有类型，没有名字，匿名字段，继承了Person的成员
    id     int
    addr   string
    name   string //和Person同名了
}
 
func main() {
    //声明（定义一个变量）
    var s Student
 
    //默认规则 （就近原则），如果能在本作用域找到此成员，就操作此成员
    //                  如果没有找到，找到继承的字段
    s.name = "mike" //操作的是Student的name，还是Person的name?, 结论为Student的
    s.sex = 'm'
    s.age = 18
    s.addr = "bj"
 
    //显式调用
    s.Person.name = "yoyo" //Person的name
 
    fmt.Printf("s = %+v\n", s)
 
}
执行结果：

1
s = {Person:{name:yoyo sex:109 age:18} id:0 addr:bj name:mike}
```

#### 非结构体匿名字段

```go

package main
 
import "fmt"
 
type mystr string //自定义类型，给一个类型改名
 
type Person struct {
    name string //名字
    sex  byte   //性别, 字符类型
    age  int    //年龄
}
 
type Student struct {
    Person //结构体匿名字段
    int    //基础类型的匿名字段
    mystr
}
 
func main() {
    s := Student{Person{"mike", 'm', 18}, 666, "hehehe"}
    fmt.Printf("s = %+v\n", s)
 
    s.Person = Person{"go", 'm', 22}
 
    fmt.Println(s.name, s.age, s.sex, s.int, s.mystr)
    fmt.Println(s.Person, s.int, s.mystr)
 
}
执行结果：
s = {Person:{name:mike sex:109 age:18} int:666 mystr:hehehe}
go 22 109 666 hehehe
{go 109 22} 666 hehehe
```

#### 结构体指针类型匿名字段

```go

package main
 
import "fmt"
 
type Person struct {
    name string //名字
    sex  byte   //性别, 字符类型
    age  int    //年龄
}
 
type Student struct {
    *Person //指针类型
    id      int
    addr    string
}
 
func main() {
    s1 := Student{&Person{"mike", 'm', 18}, 666, "bj"}
    fmt.Println(s1.name, s1.sex, s1.age, s1.id, s1.addr)
 
    //先定义变量
    var s2 Student
    s2.Person = new(Person) //分配空间
    s2.name = "yoyo"
    s2.sex = 'm'
    s2.age = 18
    s2.id = 222
    s2.addr = "sz"
    fmt.Println(s2.name, s2.sex, s2.age, s2.id, s2.addr)
 
}
执行结果：
mike 109 18 666 bj
yoyo 109 18 222 sz
```

### 方法 (method)

在面向对象编程中，一个对象其实也就是一个简单的值或者一个变量，在这个对象中会包含一些函数，**这种带有接收者的函数，我们称为方法****(method)**。 本质上，一个方法则是一个和特殊类型关联的函数。

一个面向对象的程序会用方法来表达其属性和对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。

在Go语言中，可以给任意自定义类型（包括内置类型，但不包括指针类型）添加相应的方法。

方法总是绑定对象实例，并隐式将实例作为第1实参 (receiver)，方法的语法如下：

```go
func (receiver ReceiverType) funcName(parameters) (results)`
```

1. 参数 receiver 可任意命名。如方法中未曾使用，可省略参数名。
2. 参数 receiver 类型可以是 T 或 *T。==基类型 T 不能是接⼝或指针==。
3. 不支持重载方法，也就是说，不能定义名字相同但是不同参数的方法
4. 只要接收者类型不一样，这个方法就算同名，也是不同方法，不会出现重复定义函数的错误 

```go
type long int
func (tmp long) test(){
    
}
type char byte
func (tmp char) test() {
    
}
func (tmp *long) test02 {  
    
}
type pointer *int
//pointer为接收者类型，它本身不能是指针类型
//func (tmp pointer) test(){
    
// }
```



#### 为类型添加方法

##### 为普通类型添加方法

```go

package main
 
import "fmt"
 
//面向对象，方法：给某个类型绑定一个函数
func Add01(a, b int) int {
    return a + b
}
 
type long int
 
//tmp叫接收者，接收者就是传递的一个参数
func (tmp long) Add02(other long) long {
    return tmp + other
}
 
func main() {
    var result int
    result = Add01(1, 1) //普通函数调用方式
    fmt.Println("result = ", result)
 
    //定义一个变量
    var a long = 2
 
    //调用方法格式： 变量名.函数(所需参数)
    r := a.Add02(3)
    fmt.Println("r = ", r)
 
}
执行结果：
result =  2
r =  5      //long =2  传给tmp, a.add02(3) 传给(other long)
```

##### 为结构体类型添加方法

```go

package main
 
import "fmt"
 
type Person struct {
    name string //名字
    sex  byte   //性别, 字符类型
    age  int    //年龄
}
 
//带有接收者的函数叫方法
func (tmp Person) PrintInfo() {
    fmt.Println("tmp = ", tmp)
}
 
func (p *Person) SetInfo(n string, s byte, a int) {
    p.name = n
    p.sex = s
    p.age = a
}
 
func main() {
    //定义同时初始化
    p := Person{"mike", 'm', 18}
    p.PrintInfo()
 
    var p2 Person
    (&p2).SetInfo("yoyo", 'f', 22)
    p2.PrintInfo()
}
执行结果：
tmp =  {mike 109 18}
 
tmp =  {yoyo 102 22}
```

#### 值语义和引用语义

```go
package main
 
import "fmt"
 
type Person struct {
    name string //名字
    sex  byte   //性别, 字符类型
    age  int    //年龄
}
 
//修改成员变量的值
 
//接收者为普通变量，非指针，值语义，一份拷贝
func (p Person) SetInfoValue(n string, s byte, a int) {
    p.name = n
    p.sex = s
    p.age = a
    fmt.Println("p = ", p)
    fmt.Printf("SetInfoValue &p = %p\n", &p)
}
 
//接收者为指针变量，引用传递
func (p *Person) SetInfoPointer(n string, s byte, a int) {
    p.name = n
    p.sex = s
    p.age = a
 
    fmt.Printf("SetInfoPointer p = %p\n", p)
}
 
func main() {
    s1 := Person{"go", 'm', 22}
    fmt.Printf("&s1 = %p\n", &s1) //打印地址
 
    //值语义
    //  s1.SetInfoValue("mike", 'm', 18)
    //  fmt.Println("s1 = ", s1) //打印内容
 
    //引用语义
    (&s1).SetInfoPointer("mike", 'm', 18)
    fmt.Println("s1 = ", s1) //打印内容
}
#执行结果：
&s1 = 0xc00005a400
 
SetInfoPointer p = 0xc00005a400
 
s1 =  {mike 109 18}
```

#### 方法集

类型的方法集是指可以被该类型的值调用的所有方法的集合。

用实例 value 和 pointer 调用方法（含匿名字段）不受方法集约束，编译器编总是查找全部方法，并自动转换 receiver 实参。

##### 类型为*T的方法集

```go
package main
 
import "fmt"
 
type Person struct {
    name string //名字
    sex  byte   //性别, 字符类型
    age  int    //年龄
}
//非指针
func (p Person) SetInfoValue() {
    fmt.Println("SetInfoValue")
}
//指针
func (p *Person) SetInfoPointer() {
    fmt.Println("SetInfoPointer")
}
 
func main() {
    //结构体变量是一个指针变量，它能够调用哪些方法，这些方法就是一个集合，简称方法集
    p := &Person{"mike", 'm', 18}
    p.SetInfoPointer() //func (p *Person) SetInfoPointer()
    //(*p).SetInfoPointer() //把(*p)转换成p后再调用，等价于上面
 
    //内部做的转换， 先把指针p， 转成*p后再调用
    //(*p).SetInfoValue()
    //p.SetInfoValue()
 
}
执行结果：
SetInfoPointer
```

##### 类型为T的方法集

```go

package main
 
import "fmt"
 
type Person struct {
    name string //名字
    sex  byte   //性别, 字符类型
    age  int    //年龄
}
 
func (p Person) SetInfoValue() {
    fmt.Println("SetInfoValue")
}
 
func main() {
    //普通变量
    p := Person{"mike", 'm', 18}
    p.SetInfoPointer() //func (p *Person) SetInfoPointer()
    //内部，先把p, 转为为&p再调用， (&p).SetInfoPointer()
 
    p.SetInfoValue()
}
执行结果：		
SetInfoPointer
SetInfoValue
```

#### 匿名字段

##### 方法的继承

```go
package main
 
import "fmt"
 
type Person struct {
    name string //名字
    sex  byte   //性别, 字符类型
    age  int    //年龄
}
 
//Person类型，实现了一个方法
func (tmp *Person) PrintInfo() {
    fmt.Printf("name=%s, sex=%c, age=%d\n", tmp.name, tmp.sex, tmp.age)
}
 
//有个学生，继承Person字段，成员和方法都继承了
type Student struct {
    Person //匿名字段
    id     int
    addr   string
}
 
func main() {
    s := Student{Person{"mike", 'm', 18}, 666, "bj"}
    s.PrintInfo()
}
执行结果：
name=mike, sex=m, age=18
```



##### 方法的重写

```go

//Person类型，实现了一个方法
func (tmp *Person) PrintInfo() {
    fmt.Printf("name=%s, sex=%c, age=%d\n", tmp.name, tmp.sex, tmp.age)
}
 
//有个学生，继承Person字段，成员和方法都继承了
type Student struct {
    Person //匿名字段
    id     int
    addr   string
}
 
//Student也实现了一个方法，这个方法和Person方法同名，这种方法叫重写
func (tmp *Student) PrintInfo() {
    fmt.Println("Student: tmp = ", tmp)
}
 
func main() {
    s := Student{Person{"mike", 'm', 18}, 666, "bj"}
    //就近原则：先找本作用域的方法，找不到再用继承的方法
    s.PrintInfo() //到底调用的是Person， 还是Student， 结论是Student
 
    //显式调用继承的方法
    s.Person.PrintInfo()
}
执行结果：
Student: tmp =  &{{mike 109 18} 666 bj}
 
name=mike, sex=m, age=18
```



#### 表达式

##### 方法值

```go

package main
 
import "fmt"
 
type Person struct {
    name string //名字
    sex  byte   //性别, 字符类型
    age  int    //年龄
}
 
func (p Person) SetInfoValue() {
    fmt.Printf("SetInfoValue: %p, %v\n", &p, p)
}
 
func (p *Person) SetInfoPointer() {
    fmt.Printf("SetInfoPointer: %p, %v\n", p, p)
}
 
func main() {
    p := Person{"mike", 'm', 18}
    fmt.Printf("main: %p, %v\n", &p, p)
 
    p.SetInfoPointer() //传统调用方式
 
    //保存方式入口地址
    pFunc := p.SetInfoPointer //这个就是方法值，调用函数时，无需再传递接收者，隐藏了接收者
    pFunc()                   //等价于 p.SetInfoPointer()
 
    vFunc := p.SetInfoValue
    vFunc() //等价于 p.SetInfoValue()
 
}
执行结果：
main: 0xc00005a400, {mike 109 18}
SetInfoPointer: 0xc00005a400, &{mike 109 18}
SetInfoPointer: 0xc00005a400, &{mike 109 18}
SetInfoValue: 0xc00005a4a0, {mike 109 18}
```

##### 方法表达式

```go

package main
 
import "fmt"
 
type Person struct {
    name string //名字
    sex  byte   //性别, 字符类型
    age  int    //年龄
}
 
func (p Person) SetInfoValue() {
    fmt.Printf("SetInfoValue: %p, %v\n", &p, p)
}
 
func (p *Person) SetInfoPointer() {
    fmt.Printf("SetInfoPointer: %p, %v\n", p, p)
}
 
func main() {
    p := Person{"mike", 'm', 18}
    fmt.Printf("main: %p, %v\n", &p, p)
 
    //方法值   f := p.SetInfoPointer //隐藏了接收者
    //方法表达式
    f := (*Person).SetInfoPointer
    f(&p) //显式把接收者传递过去 ====》 p.SetInfoPointer()
 
    f2 := (Person).SetInfoValue
    f2(p) //显式把接收者传递过去 ====》 p.SetInfoValue()
}
执行结果：
main: 0xc00005a400, {mike 109 18}
SetInfoPointer: 0xc00005a400, &{mike 109 18}
SetInfoValue: 0xc00005a480, {mike 109 18}
```

### 接口

在Go语言中，接口是一个自定义类型，接口类型具体描述了一系列方法的集合。

接口是一种抽象的类型，他不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合，它们只会展示他们自己的方法。==因此接口类型不能将其实例化==

Go通过接口实现了鸭子类型（ducking-type):"当看到一只鸟走起来像鸭子，游起来像鸭子，叫起来也像鸭子，那么这只鸟就可以称为鸭子"，==我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。==

#### 接口的定义和实现

- 接口命名习惯以er结尾
- 接口只有方法声明，没有实现，没有数据字段
- 接口可以匿名嵌入其他接口或嵌入到结构中

```go
package main
 
import "fmt"
 
//定义接口类型
type Humaner interface {
    //方法，只有声明，没有实现，由别的类型（自定义类型）实现
    sayhi()
}
 
type Student struct {
    name string
    id   int
}
 
//Student实现了此方法
func (tmp *Student) sayhi() {
    fmt.Printf("Student[%s, %d] sayhi\n", tmp.name, tmp.id)
}
 
type Teacher struct {
    addr  string
    group string
}
 
//Teacher实现了此方法
func (tmp *Teacher) sayhi() {
    fmt.Printf("Teacher[%s, %s] sayhi\n", tmp.addr, tmp.group)
}
 
type MyStr string
 
//MyStr实现了此方法
func (tmp *MyStr) sayhi() {
    fmt.Printf("MyStr[%s] sayhi\n", *tmp)
}
 
//定义一个普通函数，函数的参数为接口类型
//只有一个函数，可以有不同表现，多态
func WhoSayHi(i Humaner) {
    i.sayhi()
}
 
func main() {
    s := &Student{"mike", 666}
    t := &Teacher{"bj", "go"}
    var str MyStr = "hello mike"
 
    //调用同一函数，不同表现，多态，多种形态
    WhoSayHi(s)
    WhoSayHi(t)
    WhoSayHi(&str)
 
    //创建一个切片
    x := make([]Humaner, 3)
    x[0] = s
    x[1] = t
    x[2] = &str
 
    //第一个返回下标，第二个返回下标所对应的值
    for _, i := range x {
        i.sayhi()
    }
 
}
 
func main01() {
    //定义接口类型的变量
    var i Humaner
 
    //只是实现了此接口方法的类型，那么这个类型的变量（接收者类型）就可以给i赋值
    s := &Student{"mike", 666}
    i = s
    i.sayhi()
 
    t := &Teacher{"bj", "go"}
    i = t
    i.sayhi()
 
    var str MyStr = "hello mike"
    i = &str
    i.sayhi()
 
}
#执行结果：
Student[mike, 666] sayhi
Teacher[bj, go] sayhi
MyStr[hello mike] sayhi
 
Student[mike, 666] sayhi
Teacher[bj, go] sayhi
MyStr[hello mike] sayhi
```

#### 接口的继承

```go
package main
import "fmt"
type Humaner interface { //子集
	sayhi()
}
type Personer interface { //超集
	Humaner //匿名字段，继承了sayhi()
	sing(lrc string)
}
type Student struct {
	name string
	id   int
}
//Student实现了sayhi()
func (tmp *Student) sayhi() {
	fmt.Printf("Student[%s, %d] sayhi\n", tmp.name, tmp.id)
}
func (tmp *Student) sing(lrc string) {
	fmt.Println("Student在唱着：", lrc)
}
func main() {
	//定义一个接口类型的变量
	var i Personer
	s := &Student{"mike", 666}
	i = s
	i.sayhi() //继承过来的方法
	i.sing("学生哥")
}
执行结果：
Student[mike, 666] sayhi
Student在唱着： 学生哥
```

#### 接口组合

##### 接口嵌入

如果一个interface作为interface2的一个嵌入字段，那么interface2隐式的包含了interface1里面的方法

```go 
package main
import "fmt"
type Humaner interface { //子集
	sayhi()
}
type Personer interface { //超集
	Humaner //匿名字段，继承了sayhi()
	sing(lrc string)
}
type Student struct {
	name string
	id   int
}
```



##### 接口转换

```go
package main
 
import "fmt" 
 
type Humaner interface { //子集
    sayhi()
}
 
type Personer interface { //超集
    Humaner //匿名字段，继承了sayhi()
    sing(lrc string)
}
 
type Student struct {
    name string
    id   int
}
 
//Student实现了sayhi()
func (tmp *Student) sayhi() {
    fmt.Printf("Student[%s, %d] sayhi\n", tmp.name, tmp.id)
}
 
func (tmp *Student) sing(lrc string) {
    fmt.Println("Student在唱着：", lrc)
}
 
func main() {
    //超集可以转换为子集，反过来不可以
    var iPro Personer //超集
    iPro = &Student{"mike", 666}
 
    var i Humaner //子集
 
    //iPro = i //err
    i = iPro //可以，超集可以转换为子集
    i.sayhi()
 
}
执行结果：
Student[mike, 666] sayhi
```

#### 空接口

空接口不包含任何的方法，正因为如此，==所有的类型都实现了空接口==，因此空接口可以存储任意类型的数值，它有点类似C语言的void*类型

```go
var v1 interface{} = 1		// 将int类型赋值给interface()
var v2 interface{} = "abc"	// 将string类型赋值给interface{}
var v3 interface{} = &v2 	// 将*interface{}类型赋值给interface{}
var v4 interface{} = struct { X int }{1}
var v5 interface{} = &struct { X int }{1}
```

**当函数可以接受任意的实例对象时，我们会将其声明为interface{}**， 最典型的例子就是标准库fmt中PrintXXX系列的函数，

```go
func Printf(fmt string, args ...interface{})
func Println(args ...interface{})
```



```go

package main
 
import "fmt"
 
func xxx(arg ...interface{}) {
 
}
 
func main() {
    //空接口万能类型，保存任意类型的值
    var i interface{} = 1
    fmt.Println("i = ", i)
 
    i = "abc"
    fmt.Println("i = ", i)
}
执行结果：
i =  1
i =  abc
```

#### 类型断言

##### comma-ok类型断言

```go

package main
 
import "fmt"
 
type Student struct {
    name string
    id   int
}
 
func main() {
    i := make([]interface{}, 3)
    i[0] = 1                    //int
    i[1] = "hello go"           //string
    i[2] = Student{"mike", 666} //Student
 
    //类型查询，类型断言
    //第一个返回下标，第二个返回下标对应的值， data分别是i[0], i[1], i[2]
    for index, data := range i {
        //第一个返回的是值，第二个返回判断结果的真假
        if value, ok := data.(int); ok == true {
            fmt.Printf("x[%d] 类型为int, 内容为%d\n", index, value)
        } else if value, ok := data.(string); ok == true {
            fmt.Printf("x[%d] 类型为string, 内容为%s\n", index, value)
        } else if value, ok := data.(Student); ok == true {
            fmt.Printf("x[%d] 类型为Student, 内容为name = %s, id = %d\n", index, value.name, value.id)
        }
    }
 
} 
结果：
x[0] 类型为int, 内容为1
x[1] 类型为string, 内容为hello go
x[2] 类型为Student, 内容为name = mike, id = 666
```

##### 通过switch实现类型断言

```go

package main
 
import "fmt"
 
type Student struct {
    name string
    id   int
}
 
func main() {
    i := make([]interface{}, 3)
    i[0] = 1                    //int
    i[1] = "hello go"           //string
    i[2] = Student{"mike", 666} //Student
 
    //类型查询，类型断言
    for index, data := range i {
        switch value := data.(type) {
        case int:
            fmt.Printf("x[%d] 类型为int, 内容为%d\n", index, value)
        case string:
            fmt.Printf("x[%d] 类型为string, 内容为%s\n", index, value)
        case Student:
            fmt.Printf("x[%d] 类型为Student, 内容为name = %s, id = %d\n", index, value.name, value.id)
        }
 
    }
}
执行结果：
x[0] 类型为int, 内容为1
x[1] 类型为string, 内容为hello go
x[2] 类型为Student, 内容为name = mike, id = 666
```

## 异常处理

### error接口

**error接口：**
error只是一个接口类型

```go
type error interface {
    Error() string
}
```


构造error最简单的方法是调用errors.New，它会返回一个包含指定错误消息的新error实例：

```go
err := errors.New("EOF")
```


但更常用是使用fmt.Errorf，它还额外提供字符串格式化功能。

errors包：

```go
package errors

func New(text string) error { return &errorString{text} }

type errorString struct { s string }

func (e *errorString) Error() string { return e.s }  //满足error接口的是*errorString指针
```


其他包中也有其他类型满足error接口，例如syscall包中的Errno类型。

#### error接口的使用

```go
package main
 
import "fmt"
import "errors"
 
func main() {
    //var err1 error = fmt.Errorf("%s", "this is normol err")
    err1 := fmt.Errorf("%s", "this is normal err1")
    fmt.Println("err1 = ", err1)
 
    err2 := errors.New("this is normal err2")
    fmt.Println("err2 = ", err2)
}
执行结果：
err1 =  this is normal err1
err2 =  this is normal err2
```

#### error接口应用

```go

package main
 
import "fmt"
import "errors"
 
func MyDiv(a, b int) (result int, err error) {
 
    err = nil
    if b == 0 {
        err = errors.New("分母不能为0")
    } else {
        result = a / b
    }
 
    return
}
 
func main() {
    result, err := MyDiv(10, 0)
    if err != nil {
        fmt.Println("err = ", err)
    } else {
        fmt.Println("reslut = ", result)
    }
 
}
执行结果：
err =  分母不能为0
```

### panic

在通常情况下，向程序使用方报告错误状态的方式可以是返回一个额外的error类型值。

但是，当遇到不可恢复的错误状态的时候，如数组访问越界、空指针引用等，这些运行时错误会引起painc异常。这时，上述错误处理方式显然就不适合了。反过来讲，==在一般情况下，**我们不应通过调用panic函数来报告普通的错误，而应该只把它作为报告致命错误的一种方式**。当某些不应该发生的场景发生时，我们就应该调用panic。==

一般而言，==当panic异常发生时，程序会中断运行，==并立即执行在该goroutine（可以先理解成线程，在中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。

不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。

```go
func panic(v interface{})
```

#### 显式调用panic函数

```go
package main
 
import "fmt"
 
func testa() {
    fmt.Println("aaaaaaaaaaaaaaaaa")
}
 
func testb() {
    //fmt.Println("bbbbbbbbbbbbbbbbbbbb")
    //显式调用panic函数，导致程序中断
    panic("this is a panic test")
}
 
func testc() {
    fmt.Println("cccccccccccccccccc")
}
 
func main() {
    testa()
    testb()
    testc()
}
执行结果：
aaaaaaaaaaaaaaaaa
panic: this is a panic test

goroutine 1 [running]:
main.testb()
	/home/fitsh/Code/a.go:12 +0x39
main.main()
	/home/fitsh/Code/a.go:21 +0x25
exit status 2
```

#### 数组越界导致panic

```go

package main
 
import "fmt"
 
func testa() {
    fmt.Println("aaaaaaaaaaaaaaaaa")
}
 
func testb(x int) {
    var a [10]int
    a[x] = 111 //当x为20时候，导致数组越界，产生一个panic，导致程序崩溃
}
 
func testc() {
    fmt.Println("cccccccccccccccccc")
}
 
func main() {
    testa()
    testb(20)
    testc()
}
执行结果：
aaaaaaaaaaaaaaaaa
 
 
panic: runtime error: index out of range
 
goroutine 1 [running]:
main.testb(...)
    D:/GoFiles/src/hello_01/main.go:11
main.main()
    D:/GoFiles/src/hello_01/main.go:20 +0x2c
```

### recover的使用

运行时panic异常一旦被引发就会导致程序崩溃。这当然不是我们愿意看到的，因为谁也不能保证程序不会发生任何运行时错误。

不过，Go语言为我们提供了专用于“拦截”运行时panic的内建函数——recover。它可以是当前的程序从运行时panic的状态中恢复并重新获得流程控制权。

```go
func recover() interface{}
```

==**注意：recover只有在defer调用的函数中有效**==。

如果调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。


```go

package main
 
import "fmt"
 
func testa() {
    fmt.Println("aaaaaaaaaaaaaaaaa")
}
 
func testb(x int) {
    //设置recover，recover只能放在defer后面使用
    defer func() {
        //recover() //可以打印panic的错误信息
        //fmt.Println(recover())
        if err := recover(); err != nil { //产生了panic异常
            fmt.Println(err)
        }
 
    }() //别忘了(), 调用此匿名函数
 
    var a [10]int
    a[x] = 111 //当x为20时候，导致数组越界，产生一个panic，导致程序崩溃
}
 
func testc() {
    fmt.Println("cccccccccccccccccc")
}
 
func main() {
    testa()
    testb(20) //当值是1的时候，就不会越界，值是20的时候，就会越界报错。
    testc()
}
执行结果：
aaaaaaaaaaaaaaaaa
 
runtime error: index out of range //值越界
 
cccccccccccccccccc
```

延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后⼀个错误可被捕获：

```go
func test() {
    defer func() {
        fmt.Println(recover())
    }()

    defer func() {
        panic("defer panic")
    }()

    panic("test panic")
}

func main() {
    test()
    //运行结果：defer panic
}
```



## 文本文件处理

### 字符串处理

strings包

#### 字符串操作

##### Contains

```go
func Contains(s, substr string) bool
功能：字符串s中是否包含substr，返回bool值
示例：

fmt.Println(strings.Contains("seafood", "foo"))
 
fmt.Println(strings.Contains("seafood", "bar"))
 
fmt.Println(strings.Contains("seafood", ""))
 
fmt.Println(strings.Contains("", ""))
执行结果：
true
false
true
true
```

##### Join

```go
func Join(a []string, sep string) string
功能：字符串链接，把slice a通过sep链接起来　
示例：

s := []string{"foo", "bar", "baz"}
fmt.Println(strings.Join(s, ", "))
执行结果：
foo, bar, baz
```

##### Index

```go
func Index(s, sep string) int
功能：在字符串s中查找sep所在的位置，返回位置值，找不到返回-1
示例：

fmt.Println(strings.Index("chicken", "ken"))
 
fmt.Println(strings.Index("chicken", "dmr"))
执行结果：
4
-1
```

##### Repeat

```go
func Repeat(s string, count int) string
功能：重复s字符串count次，最后返回重复的字符串
示例：

fmt.Println("ba" + strings.Repeat("na", 2))
执行结果：

banana
```

##### Replace

```go
func Replace(s, old, new string, n int) string
功能：在s字符串中，把old字符串替换为new字符串，n表示替换的次数，小于0表示全部替换
示例：

fmt.Println(strings.Replace("oink oink oink", "k", "ky", 2))<br><br>fmt.Println(strings.Replace("oink oink oink", "oink", "moo", -1))
执行结果：
oinky oinky oink
<br>moo moo moo
```

##### Split

```go
func Split(s, sep string) []string
功能：把s字符串按照sep分割，返回slice
示例：

fmt.Printf("%q\n", strings.Split("a,b,c", ","))
fmt.Printf("%q\n", strings.Split("a man a plan a canal panama", "a "))
fmt.Printf("%q\n", strings.Split(" xyz ", ""))
fmt.Printf("%q\n", strings.Split("", "Bernardo O'Higgins"))
#执行结果：
["a" "b" "c"]
["" "man " "plan " "canal panama"]
[" " "x" "y" "z" " "]
[""]
```

##### Trim

```go
func Trim(s string, cutset string) string
功能：在s字符串的头部和尾部去除cutset指定的字符串
示例：
fmt.Printf("[%q]", strings.Trim(" !!! Achtung !!! ", "! "))
执行结果：
["Achtung"]
```

##### Field

```go
func Fields(s string) []string
功能：去除s字符串的空格符，并且按照空格分割返回slice
执行结果：
Fields are: ["foo" "bar" "baz"]
```

以上应用综合示例：

```go
package main
 
import (
    "fmt"
    "strings"
)
 
func main() {
    //"hellogo"中是否包含"hello", 包含返回true， 不包含返回false
    fmt.Println(strings.Contains("hellogo", "hello"))
    fmt.Println(strings.Contains("hellogo", "abc"))
 
    //Joins 组合
    s := []string{"abc", "hello", "mike", "go"}
    buf := strings.Join(s, "x")
    fmt.Println("buf = ", buf)
 
    //Index, 查找子串的位置
    fmt.Println(strings.Index("abcdhello", "hello"))
    fmt.Println(strings.Index("abcdhello", "go")) //不包含子串返回-1
 
    //重复多少次，这里重复3次
    buf = strings.Repeat("go", 3)
    fmt.Println("buf = ", buf) //"gogogo"
 
    //Split 以指定的分隔符拆分
    buf = "hello@abc@go@mike"
    s2 := strings.Split(buf, "@")
    fmt.Println("s2 = ", s2)
 
    //Trim去掉两头的字符
    buf = strings.Trim("      are u ok?          ", " ") //去掉2头空格
    fmt.Printf("buf = #%s#\n", buf)
 
    //去掉空格，把元素放入切片中
    s3 := strings.Fields("      are u ok?          ")
    //fmt.Println("s3 = ", s3)
    for i, data := range s3 {
        fmt.Println(i, ", ", data)
    }
 
}
执行结果：
true
false
buf =  abcxhelloxmikexgo
4
-1
buf =  gogogo
s2 =  [hello abc go mike]
buf = #are u ok?#
0 ,  are
1 ,  u
2 ,  ok?
```

#### 字符串转换

Append系列函数将整数等类型转换为字符串后，添加到现有的字符数组中

Format系列函数把其他类型的转换为字符串

Parse系列函数把字符串转换为其他类型

```go
package main
 
import (
    "fmt"
    "strconv"
)
 
func main() {
    //转换为字符串后追加到字节数组
    slice := make([]byte, 0, 1024)
    slice = strconv.AppendBool(slice, true)
    //第二个数为要追加的数，第3个为指定10进制方式追加
    slice = strconv.AppendInt(slice, 1234, 10)
    slice = strconv.AppendQuote(slice, "abcgohello")
 
    fmt.Println("slice = ", string(slice)) //转换string后再打印
 
    //其它类型转换为字符串
    var str string
    str = strconv.FormatBool(false)
    //'f' 指打印格式，以小数方式， -1指小数点位数(紧缩模式)， 64以float64处理
    str = strconv.FormatFloat(3.14, 'f', -1, 64)
 
    //整型转字符串，常用
    str = strconv.Itoa(6666)
    fmt.Println("str = ", str)
 
    //字符串转其它类型
    var flag bool
    var err error
    flag, err = strconv.ParseBool("true")
    if err == nil {
        fmt.Println("flag = ", flag)
    } else {
        fmt.Println("err = ", err)
    }
 
    //把字符串转换为整型
    a, _ := strconv.Atoi("567")
    fmt.Println("a = ", a)
}
#执行结果：
slice =  true1234"abcgohello"
str =  6666
flag =  true
a =  567
```

### 正则表达式

正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比纯粹的文本匹配效率低，但是它却更灵活。按照它的语法规则，随需构造出的匹配模式就能够从原始文本中筛选出几乎任何你想要得到的字符组合。

Go语言通过regexp标准包为正则表达式提供了官方支持，如果你已经使用过其他编程语言提供的正则相关功能，那么你应该对Go语言版本的不会太陌生，但是它们之间也有一些小的差异，因为Go实现的是RE2标准，除了\C，详细的语法描述参考：http://code.google.com/p/re2/wiki/Syntax

其实字符串处理我们可以使用strings包来进行搜索(Contains、Index)、替换(Replace)和解析(Split、Join)等操作，但是这些都是简单的字符串操作，他们的搜索都是大小写敏感，而且固定的字符串，如果我们需要匹配可变的那种就没办法实现了，当然如果strings包能解决你的问题，那么就尽量使用它来解决。因为他们足够简单、而且性能和可读性都会比正则好。

 

一、正则匹配规则图

参考官网： https://studygolang.com/pkgdoc

![img](https://img2018.cnblogs.com/blog/1053682/201901/1053682-20190112160307112-1408653808.png)

 

二、正则表达式

示例1:  . 匹配任意类型

```go
package main
 
import (
    "fmt"
    "regexp"
)
 
func main() {
 
    buf := "abc azc a7c aac 888 a9c  tac"
 
    //1) 解释规则, 它会解析正则表达式，如果成功返回解释器，失败会造成panic
    reg1 := regexp.MustCompile(`a.c`)
    if reg1 == nil {
        fmt.Println("regexp err")
        return
    }
 
    //2) 根据规则提取关键信息
    result1 := reg1.FindAllStringSubmatch(buf, -1)
    fmt.Println("result1 = ", result1)
}
#执行结果：
result1 =  [[abc] [azc] [a7c] [aac] [a9c]]　　
```

2、匹配a[0-9]c之间的数值

示例2：

```go
package main
 
import (
    "fmt"
    "regexp"
)
 
func main() {
 
    buf := "abc azc a7c aac 888 a9c  tac"
 
    //1) 解释规则, 它会解析正则表达式，如果成功返回解释器
    reg1 := regexp.MustCompile(`a[0-9]c`)
 
    if reg1 == nil { //解释失败，返回nil
        fmt.Println("regexp err")
        return
    }
 
    //2) 根据规则提取关键信息
    result1 := reg1.FindAllStringSubmatch(buf, -1)
    fmt.Println("result1 = ", result1)
 
}
执行结果：
result1 =  [[a7c] [a9c]]
```

执行结果：

```go
`result1 =  [[a7c] [a9c]]`
```

　　

3、\d  匹配a[0-9]c之间的数值

```go
package main
 
import (
    "fmt"
    "regexp"
)
 
func main() {
 
    buf := "abc azc a7c aac 888 a9c  tac"
 
    //1) 解释规则, 它会解析正则表达式，如果成功返回解释器
    reg1 := regexp.MustCompile(`a\dc`)
    if reg1 == nil { //解释失败，返回nil
        fmt.Println("regexp err")
        return
    }
 
    //2) 根据规则提取关键信息
    result1 := reg1.FindAllStringSubmatch(buf, -1)
    fmt.Println("result1 = ", result1)
 
}
执行结果：
result1 =  [[a7c] [a9c]]　
```

4、 +匹配前一个字符的1次或多次

示例：

```go
package main
 
import (
    "fmt"
    "regexp"
)
 
func main() {
    buf := "43.14 567 agsdg 1.23 7. 8.9 1sdljgl 6.66 7.8   "
 
    //解释正则表达式, +匹配前一个字符的1次或多次
    reg := regexp.MustCompile(`\d+\.\d+`)
    if reg == nil {
        fmt.Println("MustCompile err")
        return
    }
 
    //提取关键信息
    //result := reg.FindAllString(buf, -1)
    result := reg.FindAllStringSubmatch(buf, -1)
    fmt.Println("result = ", result)
 
}
执行结果：
1
result =  [[43.14] [1.23] [8.9] [6.66] [7.8]]　　
```

5、过滤带标签或不带标签的

```go
package main
 
import (
    "fmt"
    "regexp"
)
 
func main() {
    //``   原生字符串
    buf := `
     
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title>Go语言标准库文档中文版 | Go语言中文网 | Golang中文社区 | Golang中国</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
    <meta charset="utf-8">
    <link rel="shortcut icon" href="/static/img/go.ico">
    <link rel="apple-touch-icon" type="image/png" href="/static/img/logo2.png">
    <meta name="author" content="polaris <polaris@studygolang.com>">
    <meta name="keywords" content="中文, 文档, 标准库, Go语言,Golang,Go社区,Go中文社区,Golang中文社区,Go语言社区,Go语言学习,学习Go语言,Go语言学习园地,Golang 中国,Golang中国,Golang China, Go语言论坛, Go语言中文网">
    <meta name="description" content="Go语言文档中文版，Go语言中文网，中国 Golang 社区，Go语言学习园地，致力于构建完善的 Golang 中文社区，Go语言爱好者的学习家园。分享 Go 语言知识，交流使用经验">
</head>
    <div>和爱好</div>
    <div>哈哈
    你在吗
    不在
    </div>
    <div>测试</div>
    <div>你过来啊</div>
 
<frameset cols="15,85">
    <frame src="/static/pkgdoc/i.html">
    <frame name="main" src="/static/pkgdoc/main.html" tppabs="main.html" >
    <noframes>
    </noframes>
</frameset>
</html>
    `
 
    //解释正则表达式, +匹配前一个字符的1次或多次
    //reg := regexp.MustCompile(`<div>(.*)</div>`)
    reg := regexp.MustCompile(`<div>(?s:(.*?))</div>`)
    if reg == nil {
        fmt.Println("MustCompile err")
        return
    }
 
    //提取关键信息
    result := reg.FindAllStringSubmatch(buf, -1)
    //fmt.Println("result = ", result)
 
    //过滤<></>
    for _, text := range result {
        //过滤带标签的
        //fmt.Println("text[0] = ", text[0]) //带<></>
        //过滤不带标签的
        fmt.Println("text[1] = ", text[1]) //不带<></>
    }
}　
#执行结果：
过滤带标签的
text[0] =  <div>和爱好</div>
text[0] =  <div>哈哈
    你在吗
    不在
    </div>
text[0] =  <div>测试</div>
text[0] =  <div>你过来啊</div>
<br>//过滤不带标签的<br>text[1] =  和爱好
text[1] =  哈哈
    你在吗
    不在
     
text[1] =  测试
text[1] =  你过来啊
```

### Json处理

JSON （JavaScript Object Notation）是一种比XML更轻量级的数据交换格式，在易于人们阅读和编写的同时，也易于程序解析和生成。尽管JSON是JavaScript的一个子集，但JSON采用完全独立于编程语言的文本格式，且表现为键/值对集合的文本描述形式（类似一些编程语言中的字典结构），这使它成为较为理想的、跨平台、跨语言的数据交换语言。

 ![img](https://img2018.cnblogs.com/blog/1053682/201901/1053682-20190114100901595-167528731.png)

开发者可以用 JSON 传输简单的字符串、数字、布尔值，也可以传输一个数组，或者一个更复杂的复合结构。在 Web 开发领域中， JSON被广泛应用于 Web 服务端程序和客户端之间的数据通信。

Go语言内建对JSON的支持。使用Go语言内置的encoding/json 标准库，开发者可以轻松使用Go程序生成和解析JSON格式的数据。



JSON官方网站：http://www.json.org/

在线格式化：http://www.json.cn/

1、JSON格式处理

示例：

```json
{
    "company": "itcast",
    "subjects": [
        "Go",
        "C++",
        "Python",
        "Test"
    ],
    "isok": true,
    "price": 666.666
}
```

执行结果：

```json
{
    "company":"itcast",
    "subjects":[
        "Go",
        "C++",
        "Python",
        "Test"
    ],
    "isok":true,
    "price":666.666
}　
```

 xml格式

```xml
<?xml version="1.0" encoding="UTF-8"?><root>
  <company>itcast</company>
  <subjects>Go</subjects>
  <subjects>C++</subjects>
  <subjects>Python</subjects>
  <subjects>Test</subjects>
  <isok>true</isok>
  <price>666.666</price>
</root>
```

#### 编码Json

使用`json.Marshal()`函数可以对一组数据进行JSON格式的编码。

`func Marshal(v interface{}) ([]byte, error)`

MarshalIndent 很像 Marshal，只是用缩进对输出进行格式化

`func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)`

##### 通过结构体生成json

成员变量名首字母必须大写

```go

package main
 
import (
    "encoding/json"
    "fmt"
)
 
//成员变量名首字母必须大写
type IT struct {
    Company  string
    Subjects []string
    IsOk     bool
    Price    float64
}
 
func main() {
    //定义一个结构体变量，同时初始化
    s := IT{"itcast", []string{"Go", "C++", "Python", "Test"}, true, 666.666}
 
    //编码，根据内容生成json文本
    buf, err := json.Marshal(s)
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
    fmt.Println("buf = ", string(buf))
}
执行结果：
buf =  {"Company":"itcast","Subjects":["Go","C++","Python","Test"],"IsOk":true,"Price":666.666}
```

```go
package main
 
import (
    "encoding/json"
    "fmt"
)
 
//成员变量名首字母必须大写
type IT struct {
    Company  string
    Subjects []string
    IsOk     bool
    Price    float64
}
 
func main() {
    //定义一个结构体变量，同时初始化
    s := IT{"itcast", []string{"Go", "C++", "Python", "Test"}, true, 666.666}
 
    //编码，根据内容生成json文本
    buf, err := json.MarshalIndent(s, "", " ") //格式化编码
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
 
    fmt.Println("buf = ", string(buf))
}
执行结果：
buf =  {
    "Company": "itcast",
    "Subjects": [
        "Go",
        "C++",
        "Python",
        "Test"
    ],
    "IsOk": true,
    "Price": 666.666
}
```

###### struct_tag的使用 

（通过二次编码,可以把大写变成小写，还可以以字符串方式输出）

```go
package main
 
import (
    "encoding/json"
    "fmt"
)
 
//成员变量名首字母必须大写
type IT struct {
    //Company  string   `json:"-"` //此字段不会输出到屏幕
 
    //下面的写法都是二次编码,可以把大写变成小写
    Company  string   `json:"company"`
    Subjects []string `json:"subjects"`
    IsOk     bool     `json:"isok"`
    //转成字符串再输出编码
    //IsOk  bool    `json:"string"`
    Price float64 `json:"price"`
}
 
func main() {
    //定义一个结构体变量，同时初始化
    s := IT{"itcast", []string{"Go", "C++", "Python", "Test"}, true, 666.666}
 
    //编码，根据内容生成json文本
    buf, err := json.MarshalIndent(s, "", " ") //格式化编码
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
 
    fmt.Println("buf = ", string(buf))
}
执行结果：
buf =  {
 "company": "itcast",
 "subjects": [
  "Go",
  "C++",
  "Python",
  "Test"
 ],
 "isok": true,
 "price": 666.666
}
```

##### 通过map生成json

```go
package main
 
import (
    "encoding/json"
    "fmt"
)
 
func main() {
    //创建一个map
    m := make(map[string]interface{}, 4)
    m["company"] = "itcast"
    m["subjects"] = []string{"Go", "C++", "Python", "Test"}
    m["isok"] = true
    m["price"] = 666.666
 
    //编码成json
    result, err := json.Marshal(m)
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
    fmt.Println("result = ", string(result))
}
执行结果：
result =  {"company":"itcast","isok":true,"price":666.666,"subjects":["Go","C++","Python","Test"]}
 
```

```go
package main
 
import (
    "encoding/json"
    "fmt"
)
 
func main() {
    //创建一个map
    m := make(map[string]interface{}, 4)
    m["company"] = "itcast"
    m["subjects"] = []string{"Go", "C++", "Python", "Test"}
    m["isok"] = true
    m["price"] = 666.666
 
    //编码成json
    result, err := json.MarshalIndent(m, "", "  ")
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
    fmt.Println("result = ", string(result))
}
执行结果：
result =  {
    "company": "itcast",
    "isok": true,
    "price": 666.666,
    "subjects": [
        "Go",
        "C++",
        "Python",
        "Test"
    ]
}
```

#### 解码Json

##### json解析到结构体

```go

package main
 
import (
    "encoding/json"
    "fmt"
)
 
type IT struct {
    Company  string   `json:"company"`
    Subjects []string `json:"subjects"` //二次编码
    IsOk     bool     `json:"isok"`
    Price    float64  `json:"price"`
}
 
func main() {
 
    jsonBuf := `
    {
    "company": "itcast",
    "subjects": [
        "Go",
        "C++",
        "Python",
        "Test"
    ],
    "isok": true,
    "price": 666.666
}`
 
    var tmp IT                                   //定义一个结构体变量
    err := json.Unmarshal([]byte(jsonBuf), &tmp) //第二个参数要地址传递
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
    //fmt.Println("tmp = ", tmp)
    fmt.Printf("tmp = %+v\n", tmp)
}
执行结果：
tmp = {Company:itcast Subjects:[Go C++ Python Test] IsOk:true Price:666.666}
```

定义结构体，解析你想生成的字段

```go
package main
 
import (
    "encoding/json"
    "fmt"
)
 
type IT struct {
    Company  string   `json:"company"`
    Subjects []string `json:"subjects"` //二次编码
    IsOk     bool     `json:"isok"`
    Price    float64  `json:"price"`
}
 
func main() {
 
    jsonBuf := `
    {
    "company": "itcast",
    "subjects": [
        "Go",
        "C++",
        "Python",
        "Test"
    ],
    "isok": true,
    "price": 666.666
}`
 
    var tmp IT                                   //定义一个结构体变量
    err := json.Unmarshal([]byte(jsonBuf), &tmp) //第二个参数要地址传递
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
 
    type IT2 struct {
        Subjects []string `json:"subjects"` //二次编码
    }
 
    var tmp2 IT2
    err = json.Unmarshal([]byte(jsonBuf), &tmp2) //第二个参数要地址传递
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
    fmt.Printf("tmp2 = %+v\n", tmp2)
 
}
执行结果：
tmp2 = {Subjects:[Go C++ Python Test]}
```

##### json解析到map

（通过类型断言，找到值和value类型）

```go
package main
 
import (
    "encoding/json"
    "fmt"
)
 
func main() {
    jsonBuf := `
    {
    "company": "itcast",
    "subjects": [
        "Go",
        "C++",
        "Python",
        "Test"
    ],
    "isok": true,
    "price": 666.666
}`
 
    //创建一个map
    m := make(map[string]interface{}, 4)
 
    err := json.Unmarshal([]byte(jsonBuf), &m) //第二个参数要地址传递
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
    fmt.Printf("m = %+v\n", m)
 
    var str string
 
    //类型断言, 值，它是value类型
    for key, value := range m {
        //fmt.Printf("%v ============> %v\n", key, value)
        switch data := value.(type) {
        case string:
            str = data
            fmt.Printf("map[%s]的值类型为string, value = %s\n", key, str)
        case bool:
            fmt.Printf("map[%s]的值类型为bool, value = %v\n", key, data)
        case float64:
            fmt.Printf("map[%s]的值类型为float64, value = %f\n", key, data)
        case []string:
            fmt.Printf("map[%s]的值类型为[]string, value = %v\n", key, data)
        case []interface{}:
            fmt.Printf("map[%s]的值类型为[]interface, value = %v\n", key, data)
        }
 
    }
 
}
执行结果：
m = map[isok:true price:666.666 company:itcast subjects:[Go C++ Python Test]]
 
map[company]的值类型为string, value = itcast
map[subjects]的值类型为[]interface, value = [Go C++ Python Test]
map[isok]的值类型为bool, value = true
map[price]的值类型为float64, value = 666.666000
```

###  文件分类和为什么需要文件

1、文件分类和为什么需要文件

设备文件：

屏幕（标准输出设备） fmt.Println()  从标准输出设备写内容

键盘（标准输入设备） fmt.Scan()   从标准输入设备读取内容

 

磁盘文件，放在存储设备上的文件

1、文本文件   以记事本打开，能看到内容（不是乱码）

2、二进制文件 以记事本打开 ，能看到内容（是乱码）

 

为什么需要文件？

1、内存掉电丢失，程序结束，内存中的内容消失

2、文件放磁盘，程序结束，文件还是存在

### 文件常用操作接口介绍与使用

#### 文件常用操作接口介绍

##### 创建文件

法1： 推荐用法

```go
func Create(name string) (file *File, err Error) //根据提供的文件名创建新的文件，返回一个文件对象，默认权限是0666的文件，返回的文件对象是可读写的。如果存在文件，则清空
```

法2:

```go
func NewFile(fd uintptr, name string) *File//根据文件描述符创建相应的文件，返回一个文件对象`
```

##### 打开文件

法1：

```go
func Open(name string) (file *File, err Error)//该方法打开一个名称为name的文件，但是是只读方式，内部实现其实调用了OpenFile。`
```

法2:  推荐用法

```go
func OpenFile(name string, flag int, perm uint32) (file *File, err Error)//打开名称为name的文件，flag是打开的方式，只读、读写等，perm是权限`
```

##### 写文件

```go
法1： func (file *File) Write(b []byte) (n int, err Error)//写入byte类型的信息到文件 
法2：func (file *File) WriteAt(b []byte, off int64) (n int, err Error)//在指定位置开始写入byte类型的信息 
法3：func (file *File) WriteString(s string) (ret int, err Error)//写入string信息到文件`
```

##### 读文件

```go
法1：func (file *File) Read(b []byte) (n int, err Error)//读取数据到b中
法2：func (file *File) ReadAt(b []byte, off int64) (n int, err Error)//从off开始读取数据到b中
```

##### 删除文件

```go
func Remove(name string) Error//调用该函数就可以删除文件名为name的文件`
```

#### 标准设备文件的使用

示例：

```go
package main
 
import (
    "fmt"
    "os"
)
 
func main() {
 
    //os.Stdout.Close() //关闭后，无法输出
    //fmt.Println("are u ok?") //往标准输出设备(屏幕)写内容
 
    //标准设备文件(os.Stdout)，默认已经打开，用户可以直接使用
    //os.Stdout
    os.Stdout.WriteString("are u ok?\n")
 
    //os.Stdin.Close() //关闭后，无法输入
    var a int
    fmt.Println("请输入a: ")
    fmt.Scan(&a) //从标准输入设备中读取内容，放在a中
    fmt.Println("a = ", a)
}
```

\#执行结果：

```shell
are u ok?
请输入a: 
4444
a =  4444
```

#### 文件的读写

##### WriteString的使用

```go
package main
 
import (
    "fmt"
    "os"
)
 
func WriteFile(path string) {
    f, err := os.Create(path)
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
 
    //使用完毕，需要关闭文件
    defer f.Close()
 
    var buf string
 
    for i := 0; i < 10; i++ {
        //"i = 1\n", 这个字符串存储在buf中
        buf = fmt.Sprintf("i = %d\n", i)
        //fmt.Println("buf = ", buf)
 
        n, err := f.WriteString(buf)
        if err != nil {
            fmt.Println("err = ", err)
        }
        fmt.Println("n = ", n)
    }
}
 
func main() {
    path := "./demo.txt"
 
    WriteFile(path)
}
执行结果：    生成一个demo.txt文件
i = 0
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
```

##### read的使用

读文件

```go
package main
 
import (
    "fmt"
    "io"
    "os"
)
 
func WriteFile(path string) {
    f, err := os.Create(path)
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
 
    //使用完毕，需要关闭文件
    defer f.Close()
 
    var buf string
 
    for i := 0; i < 10; i++ {
        //"i = 1\n", 这个字符串存储在buf中
        buf = fmt.Sprintf("i = %d\n", i)
        //fmt.Println("buf = ", buf)
 
        n, err := f.WriteString(buf)
        if err != nil {
            fmt.Println("err = ", err)
        }
        fmt.Println("n = ", n)
    }
}
 
func ReadFile(path string) {
    f, err := os.Open(path)
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
 
    //关闭文件
    defer f.Close()
 
    buf := make([]byte, 1024*2) //2k大小
 
    //n代表从文件读取内容的长度
    n, err1 := f.Read(buf)
    if err1 != nil && err1 != io.EOF { //文件出错，同时没有到结尾
        fmt.Println("err1 = ", err1)
        return
    }
 
    fmt.Println("err1 = ", string(buf[:n]))
 
}
 
func main() {
    path := "./demo.txt"
    //写
    //WriteFile(path)
    //读
    ReadFile(path)
}
#执行结果： （会生成一个demo.txt的文件）
i = 0
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
```

##### 借助bufio实现按行读取内容

```go
package main
 
import (
    "bufio"
    "fmt"
    "io"
    "os"
)
 
func WriteFile(path string) {
    //打开文件，新建文件
    f, err := os.Create(path)
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
 
    //使用完毕，需要关闭文件
    defer f.Close()
 
    var buf string
 
    for i := 0; i < 10; i++ {
        //"i = 1\n", 这个字符串存储在buf中
        buf = fmt.Sprintf("i = %d\n", i)
        //fmt.Println("buf = ", buf)
 
        n, err := f.WriteString(buf)
        if err != nil {
            fmt.Println("err = ", err)
        }
        fmt.Println("n = ", n)
    }
}
 
func ReadFile(path string) {
    //打开文件
    f, err := os.Open(path)
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
 
    //关闭文件
    defer f.Close()
 
    buf := make([]byte, 1024*2) //2k大小
 
    //n代表从文件读取内容的长度
    n, err1 := f.Read(buf)
    if err1 != nil && err1 != io.EOF { //文件出错，同时没有到结尾
        fmt.Println("err1 = ", err1)
        return
    }
 
    fmt.Println("buf = ", string(buf[:n]))
 
}
 
//每次读取一行
func ReadFileLine(path string) {
    //打开文件
    f, err := os.Open(path)
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
 
    //关闭文件
    defer f.Close()
 
    //新建一个缓冲区，把内容先放在缓冲区
    r := bufio.NewReader(f)
 
    for {
        //遇到'\n'结束读取, 但是'\n'也读取进入
        buf, err := r.ReadBytes('\n')
        if err != nil {
            if err == io.EOF { //文件已经结束
                break
            }
            fmt.Println("err = ", err)
        }
 
        fmt.Printf("buf = #%s#\n", string(buf))
    }
 
}
 
func main() {
    path := "./demo.txt"
 
    //WriteFile(path)
    //ReadFile(path)
    ReadFileLine(path)
}
执行结果：
err1 =  i = 0
 
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
```

#### 案例：拷贝文件

```go
package main
 
import (
    "fmt"
    "io"
    "os"
)
 
func main() {
    list := os.Args //获取命令行参数
    if len(list) != 3 {
        fmt.Println("usage: xxx srcFile dstFile")
        return
    }
     
    srcFileName = list[1]
    drcFileName = list[1]
     
    if srcFileName == drcFileName {
        fmt.Println("源文件和目的文件名字不能相同")
        return
    }
         
    //只读方式打开源文件
    sF, err1 := os.Open(srcFileName)
    if  err1 != nil {
        fmt.Println("err1 = ", err1)
        return
    }   
      
    //新建目的文件
    dF, err2 := os.Create(srcFileName)
    if err2 != nil {
        fmt.Println("err2 = ", err2)
        return
    }
     
    //操作完毕，需要关闭文件
    defer sF.Close()
    defer dF.Close()
     
    //核心处理，从源文件读取内容，往目的文件写，读多少写多少
    buf := make([]byte 4*1024)  //4k大小临时缓冲区
    for {
        n, err := sF.Read(but)  //从源文件读取内容
        if err != nil {
            if err == io.EOF  //文件读取完毕
               break
        }
        fmt.Println("err = ", err)
    }
    //往目的文件写，读多少写多少
    dF.Write(buf[:n])
     
}
执行结果：
#在cmd中运行：
D:\GoFiles\src\hello_01>go run mai1.go 2.txt 1.txt
 
err =  EOF
```



## 并发编程

### 概述

#### 并行和并发

并行和并发的概念 

**并行(parallel)**：指在同一时刻，有多条指令在多个处理器上同时执行。 

**并发(concurrency)**：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。

2、并行和并发的区别

- 并发是两个队列**交替**使用一台咖啡机 
- 并行是两个队列**同时**使用两台咖啡机

3、并发和并行原理图

![img](https://img2018.cnblogs.com/blog/1053682/201901/1053682-20190115141422456-569378359.png)  

#### Go语言并发优势

有人把Go比作21世纪的C语言，第一是因为Go语言设计简单，第二，21世纪最重要的就是并行程序设计，而Go从语言层面就支持了并行。同时，并发程序的内存管理有时候是非常复杂的，而Go语言提供了自动垃圾回收机制。

Go语言为并发编程而内置的上层API基于CSP(communicating sequential processes, 顺序通信进程)模型。这就意味着显式锁都是可以避免的，因为Go语言通过相册安全的通道发送和接受数据以实现同步，这大大地简化了并发程序的编写。

一般情况下，一个普通的桌面计算机跑十几二十个线程就有点负载过大了，但是同样这台机器却可以轻松地让成百上千甚至过万个goroutine进行资源竞争。

### goroutine

#### goroutine是什么

goroutine是Go并行设计的核心。goroutine说到底其实就是协程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。

#### 创建goutine

　只需在函数调⽤语句前添加 go 关键字，就可创建并发执⾏单元。开发⼈员无需了解任何执⾏细节，调度器会自动将其安排到合适的系统线程上执行。

　　在并发编程里，我们通常想讲一个过程切分成几块，然后让每个goroutine各自负责一块工作。当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。

```go
`package` `main` `import` `(``    ``"fmt"``    ``"time"``)` `func` `newTask() {``    ``for` `{``        ``fmt.Println(``"this is a newTask"``)``        ``time.Sleep(time.Second) ``//延时1s``    ``}``}` `func` `main() {` `    ``go` `newTask() ``//新建一个协程， 新建一个任务` `    ``for` `{``        ``fmt.Println(``"this is a main goroutine"``)``        ``time.Sleep(time.Second) ``//延时1s``    ``}``}`
```

执行结果：

```
`this is a main goroutine``this is a newTask``this is a newTask``this is a main goroutine``this is a newTask`
```

 原理图：

![img](https://img2018.cnblogs.com/blog/1053682/201901/1053682-20190115153041454-1684821061.png)

#### 主goutine退出

主协程退出导致其它子协程也退出

```go
示例：
package main
 
import (
    "fmt"
    "time"
)
 
//主协程退出了，其它子协程也要跟着退出
func main() {
 
    go func() {
        i := 0
        for {
            i++
            fmt.Println("子协程 i = ", i)
            time.Sleep(time.Second)
        }
 
    }() //别忘了()
 
    i := 0
    for {
        i++
        fmt.Println("main i = ", i)
        time.Sleep(time.Second)
 
        if i == 2 {
            break
        }
    }
 
}
执行结果:
main i =  1
子协程 i =  1
子协程 i =  2
main i =  2
```



#### runtime包

##### Gosched

Gosched的使用

runtime.Gosched() ==**用于让出CPU时间片**==，让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。

这就像跑接力赛，A跑了一会碰到代码runtime.Gosched() 就把接力棒交给B了，A歇着了，B继续跑。 

示例： 

```go
`package` `main` `import` `(``    ``"fmt"``    ``"runtime"``)` `func` `main() {` `    ``go` `func``() {``        ``for` `i := 0; i < 5; i++ {``            ``fmt.Println(``"go"``)``        ``}` `    ``}()` `    ``for` `i := 0; i < 4; i++ {``        ``//让出时间片，先让别的协议执行，它执行完，再回来执行此协程``        ``runtime.Gosched()``        ``fmt.Println(``"hello"``)``    ``}``}`
```

执行结果：

```
`go``go``go``go``go``hello``hello``hello``hello`
```

##### Goexit

Goexit的使用（终止协程）

```go
`package` `main` `import` `(``    ``"fmt"``    ``"runtime"``)` `func` `test() {``    ``defer` `fmt.Println(``"ccccccccccccc"``)` `    ``//return           //终止此函数``    ``runtime.Goexit() ``//终止所在的协程` `    ``fmt.Println(``"dddddddddddddddddddddd"``)``}` `func` `main() {` `    ``//创建新建的协程``    ``go` `func``() {``        ``fmt.Println(``"aaaaaaaaaaaaaaaaaa"``)` `        ``//调用了别的函数``        ``test()` `        ``fmt.Println(``"bbbbbbbbbbbbbbbbbbb"``)``    ``}() ``//别忘了()` `    ``//特地写一个死循环，目的不让主协程结束``    ``for` `{``    ``}``}`
```

执行结果：

```
`aaaaaaaaaaaaaaaaaa``ccccccccccccc`
```

##### GOMAXPROCS

调用runtime.GOMAXPROCS()用来设置可以并行计算的CPU核数的最大值，并返回之前的值

```go
package main
 
import (
    "fmt"
    "runtime"
)
 
func main() {
    //n := runtime.GOMAXPROCS(1) //指定以1核运算
    n := runtime.GOMAXPROCS(4) //指定以4核运算
    fmt.Println("n = ", n)
 
    for {
        go fmt.Print(1)
 
        fmt.Print(0)
    }
}
```

执行结果：

```
00000000000000000000000000000000000000000000000000000000000000000000000000011111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111110000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111100000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000001111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111100000000000000000000000000000000000000000000000000000000000000000000
```

### 多任务资源竞争问题

```go
package main
 
import (
    "fmt"
    "time"
)
 
//定义一个打印机，参数为字符串，按每个字符打印
//打印机属于公共资源
func Printer(str string) {
    for _, data := range str {
        fmt.Printf("%c", data)
        time.Sleep(time.Second)
    }
    fmt.Printf("\n")
}
 
func person1() {
    Printer("hello")
}
 
func person2() {
    Printer("world")
}
 
func main() {
    //新建2个协程，代表2个人，2个人同时使用打印机
    go person1()
    go person2()
 
    //特地不让主协程结束，死循环
    for {
 
    }
}　　
```

执行结果

```shell
hweorllldo
```

程序执行过程：  一人打印一个字符，这样就乱了。

 

![img](https://img2018.cnblogs.com/blog/1053682/201901/1053682-20190116142611039-1987824159.png)

### channel

goroutine运行在相同的地址空间，因此访问共享内存必须做好同步。goroutine奉行==**通过通信来共享内存，而不是共享内存来通信。**==

引用类型channel是CSP模式的具体实现，用于多个goroutine通讯，其内部实现了同步，确保并发安全。

#### channel类型

和map类似，channel也一个对应make创建的底层数据结构的引用。

 当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。 

 定义一个channel时，也需要定义发送到channel的值的类型。channel可以使用内置的make()函数来创建： 

```go
`make(``chan` `Type) ``//等价于make(chan Type, 0)``make(``chan` `Type, capacity)`
```

 当 capacity= 0 时，channel 是无缓冲阻塞读写的，当capacity> 0 时，channel 有缓冲、是非阻塞的，直到写满 capacity个元素才阻塞写入。

 channel通过操作符<-来接收和发送数据，发送和接收数据语法：

 

```go
`channel <- value      ``//发送value到channel``<-channel             ``//接收并将其丢弃``x := <-channel        ``//从channel中接收数据，并赋值给x``x, ok := <-channel    ``//功能同上，同时检查通道是否已关闭或者是否为空`
```

默认情况下，channel接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得goroutine同步变的更加的简单，而不需要显式的lock。

```go
package main
 
import (
    "fmt"
    "time"
)
 
//全局变量，创建一个channel
var ch = make(chan int)
 
//定义一个打印机，参数为字符串，按每个字符打印
//打印机属于公共资源
func Printer(str string) {
    for _, data := range str {
        fmt.Printf("%c", data)
        time.Sleep(time.Second)
    }
    fmt.Printf("\n")
}
 
//person1执行完后，才能到person2执行
func person1() {
    Printer("hello")
    ch <- 666 //给管道写数据，发送
}
 
func person2() {
    <-ch //从管道取数据，接收，如果通道没有数据他就会阻塞
    Printer("world")
}
 
func main() {
    //新建2个协程，代表2个人，2个人同时使用打印机
    go person1()
    go person2()
 
    //特地不让主协程结束，死循环
    for {
 
    }
}
```

执行结果：

```shell
hello
world
```



#### 无缓冲的channel

无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。

这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。如果两个goroutine没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。

这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。无缓冲的channel创建格式：

```go
    make(chan Type) //等价于make(chan Type, 0)
```

如果没有指定缓冲区容量，那么该通道就是同步的，因此会阻塞到发送者准备好发送和接收者准备好接收。

```go
package main
 
import (
    "fmt"
    "time"
)
 
func main() {
    //创建一个无缓存的channel
    ch := make(chan int, 0)
 
    //len(ch)缓冲区剩余数据个数， cap(ch)缓冲区大小
    fmt.Printf("len(ch) = %d, cap(ch)= %d\n", len(ch), cap(ch))
 
    //新建协程
    go func() {
        for i := 0; i < 3; i++ {
            fmt.Printf("子协程：i = %d\n", i)
            ch <- i //往chan写内容
        }
    }()
 
    //延时
    time.Sleep(2 * time.Second)
  
    for i := 0; i < 3; i++ {
        num := <-ch //读管道中内容，没有内容前，阻塞
        fmt.Println("num = ", num)
    }
 
}
```

执行结果：

```shell
len(ch) = 0, cap(ch)= 0
子协程：i = 0
num =  0
子协程：i = 1    
子协程：i = 2   
num =  1
num =  2
```



#### 有缓冲的channel

有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。

这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。

这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。


有缓冲的channel创建格式

`make(chan Type, capacity)`

如果给定一个缓冲区容量 ，通道就是异步的。只要缓冲区有未使用空间用于发送数据，或还包含可以接收的数据，那么其通道就是无阻塞的进行。

示例：  有缓存会阻塞，当读取完其中数值时，又可以写入。

```go
package main
 
import (
    "fmt"
    "time"
)
 
func main() {
    //创建一个有缓存的channel
    ch := make(chan int, 3)
 
    //len(ch)缓冲区剩余数据个数， cap(ch)缓冲区大小
    fmt.Printf("len(ch) = %d, cap(ch)= %d\n", len(ch), cap(ch))
 
    //新建协程
    go func() {
        for i := 0; i < 10; i++ {
            ch <- i //往chan写内容
            fmt.Printf("子协程[%d]: len(ch) = %d, cap(ch)= %d\n", i, len(ch), cap(ch))
        }
    }()
 
    //延时
    time.Sleep(2 * time.Second)
 
    for i := 0; i < 10; i++ {
        num := <-ch //读管道中内容，没有内容前，阻塞
        fmt.Println("num = ", num)
    }
 
}
```

执行结果

```
len(ch) = 0, cap(ch)= 3
子协程[0]: len(ch) = 1, cap(ch)= 3
子协程[1]: len(ch) = 2, cap(ch)= 3
子协程[2]: len(ch) = 3, cap(ch)= 3
num =  0
num =  1
num =  2
num =  3
子协程[3]: len(ch) = 3, cap(ch)= 3
子协程[4]: len(ch) = 0, cap(ch)= 3
num =  4
num =  5
子协程[5]: len(ch) = 1, cap(ch)= 3
子协程[6]: len(ch) = 0, cap(ch)= 3
子协程[7]: len(ch) = 1, cap(ch)= 3
子协程[8]: len(ch) = 2, cap(ch)= 3
子协程[9]: len(ch) = 3, cap(ch)= 3
num =  6
num =  7
num =  8
num =  9
```

#### 关闭channel

注意：

- channel不像文件一样需要经常去关闭，只有当你确实没有任何发送数据了，或者你想显式的结束range循环之类的，才去关闭channel
- 关闭channel后无法再向channel发送数据，（引发panic错误后导致接收立即返回零值）
- 关闭channel后，可以继续向channel接收数据
- 对于nil channel，无论接收都会被阻塞

```go
package main
 
import (
    "fmt"
)
 
func main() {
    ch := make(chan int) //创建一个无缓存channel
 
    //新建一个goroutine
    go func() {
        for i := 0; i < 5; i++ {
            ch <- i //往通道写数据
        }
        //不需要再写数据时，关闭channel
        close(ch)
        //ch <- 666 //关闭channel后无法再发送数据
 
    }() //别忘了()
 
    for {
        //如果ok为true，说明管道没有关闭
        if num, ok := <-ch; ok == true {
            fmt.Println("num = ", num)
        } else { //管道关闭
            break
        }
    }
}
执行结果：
num =  0
num =  1
num =  2
num =  3
num =  4
```



#### range

通过range遍历channel内容

```go
package main
 
import (
    "fmt"
)
 
func main() {
    ch := make(chan int) //创建一个无缓存channel
 
    //新建一个goroutine
    go func() {
        for i := 0; i < 5; i++ {
            ch <- i //往通道写数据
        }
        //不需要再写数据时，关闭channel
        close(ch)
        //ch <- 666 //关闭channel后无法再发送数据
 
    }() //别忘了()
 
    for num := range ch {
        fmt.Println("num = ", num)
    }
 
}
```

执行结果

```shell
num =  0
num =  1
num =  2
num =  3
num =  4
```



#### 单方向的channel

默认情况下，通道是双向的，也就是，既可以往里面发送数据，也可以从里面接收数据

但是，我们经常见一个通道作为参数进行传递而只希望对方是单向的，要么只让它发送数据，要么只让它接收数据，这时候我们可以指定通道的方向。

单向channel变量的声明非常简单，如下

```go
var ch1 chan int // ch1是一个正常的channel，不是单向的
var ch2 chan<- float64 // ch2是单向channel，只用于写float64数据
var ch3 <-chan int // ch3是单向channel，只用于读取int数据
```

- chan<- 表示数据进入管道，要把数据写进管道，对于调用者就是输出。
- <-chan 表示数据从管道出来，对于调用者就是得到管道的数据，当然就是输入。

可以将 channel 隐式转换为单向队列，只收或只发，不能将单向 channel 转换为普通 channel：

```go
    c := make(chan int, 3)
    var send chan<- int = c // send-only
    var recv <-chan int = c // receive-only
    send <- 1
    //<-send //invalid operation: <-send (receive from send-only type chan<- int)
    <-recv
    //recv <- 2 //invalid operation: recv <- 2 (send to receive-only type <-chan int)

    //不能将单向 channel 转换为普通 channel
    d1 := (chan int)(send) //cannot convert send (type chan<- int) to type chan int
    d2 := (chan int)(recv) //cannot convert recv (type <-chan int) to type chan int
```

```go
//   chan<- //只写
func counter(out chan<- int) {
    defer close(out)
    for i := 0; i < 5; i++ {
        out <- i //如果对方不读 会阻塞
    }
}

//   <-chan //只读
func printer(in <-chan int) {
    for num := range in {
        fmt.Println(num)
    }
}

func main() {
    c := make(chan int) //   chan   //读写

    go counter(c) //生产者
    printer(c)    //消费者

    fmt.Println("done")
}
```



##### 单向channel特点

```go
package main
 
//"fmt"
 
func main() {
    //创建一个channel, 双向的
    ch := make(chan int)
 
    //双向channel能隐式转换为单向channel
    var writeCh chan<- int = ch //只能写，不能读
    var readCh <-chan int = ch  //只能读，不能写
 
    writeCh <- 666 //写
    //<-writeCh //err,  invalid operation: <-writeCh (receive from send-only type chan<- int)
 
    <-readCh //读
    //readCh <- 666 //写， err,  invalid operation: readCh <- 666 (send to receive-only type <-chan int)
 
    //单向无法转换为双向
    //var ch2 chan int = writeCh //cannot use writeCh (type chan<- int) as type chan int in assignment
 
}
```

##### 单向channel的应用

生产者消费者模型

```go
package main
 
import (
    "fmt"
)
 
//此通道只能写，不能读
func producer(out chan<- int) {
    for i := 0; i < 10; i++ {
        out <- i * i
    }
    close(out)
}
 
//此channel只能读，不能写
func consumer(in <-chan int) {
    for num := range in {
        fmt.Println("num = ", num)
    }
}
 
func main() {
    //创建一个双向通道
    ch := make(chan int)
 
    //生产者，生产数字，写入channel
    //新开一个协程
    go producer(ch) //channel传参，引用传递
 
    //消费者，从channel读取内容，打印
    consumer(ch)
}
执行结果：
num =  0
num =  1
num =  4
num =  9
num =  16
num =  25
num =  36
num =  49
num =  64
num =  81
```



#### 定时器

##### Timer

Timer是一个定时器，代表未来的一个单一事件，你可以告诉timer你要等待多长时间，它提供一个channel，在将来的那个时间那个channel提供了一个时间值。

Timer的使用 

示例： #创建一个定时器，设置时间为2s，2s后，往time通道写内容（当前时间）

```go
package main
 
import (
    "fmt"
    "time"
)
 
//验证time.NewTimer()，时间到了，只会响应一次
func main() {
    timer := time.NewTimer(1 * time.Second)
 
    for {
        <-timer.C
        fmt.Println("时间到")
    }
}
 
func main01() {
    //创建一个定时器，设置时间为2s，2s后，往time通道写内容（当前时间）
    timer := time.NewTimer(2 * time.Second)
    fmt.Println("当前时间：", time.Now())
 
    //2s后，往timer.C写数据，有数据后，就可以读取
    t := <-timer.C //channel没有数据前后阻塞
    fmt.Println("t = ", t)
}
执行结果：
时间到
fatal error: all goroutines are asleep - deadlock!   //
 
goroutine 1 [chan receive]:
main.main()
    D:/GoFiles/src/hello_01/mai1.go:13 +0x54
```

定时器停止

```go
package main
 
import (
    "fmt"
    "time"
)
 
func main() {
    timer := time.NewTimer(3 * time.Second)
 
    go func() {
        <-timer.C
        fmt.Println("子协程可以打印了，因为定时器的时间到")
    }()
 
    //timer.Stop() //停止定时器,没办法打印内容
 
    for {
 
    }
}
执行结果:
//停止定时器,没办法打印内容
```

定时器重置

```go
package main
 
import (
    "fmt"
    "time"
)
 
func main() {
    timer := time.NewTimer(3 * time.Second)
    ok := timer.Reset(1 * time.Second) //重新设置为1s
    fmt.Println("ok = ", ok)
 
    <-timer.C
    fmt.Println("时间到")
 
}
执行结果：
ok =  true
时间到
```



##### Ticker

Ticker是一个定时触发的计时器，它会以一个间隔(interval)往channel发送一个事件(当前时间)，而channel的接收者可以以固定的时间间隔从channel中读取事件。

示例： Ticker 每沿时一秒输出一个结果

```go
package main
 
import (
    "fmt"
    "time"
)
 
func main() {
    ticker := time.NewTicker(1 * time.Second)
 
    i := 0
    for {
        <-ticker.C
 
        i++
        fmt.Println("i = ", i)
<br>                //输出5次就停止
        if i == 5 {
            ticker.Stop()
            break
        }
    }
}
执行结果：
i =  1
i =  2
i =  3
i =  4
i =  5
```



### select

#### select作用

Go里面提供了一个关键字select，通过select可以监听channel上的数据流动。

select的用法与switch语言非常类似，由select开始一个新的选择块，每个选择条件由case语句来描述。

与switch语句可以选择任何可使用相等比较的条件相比， select有比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作，大致的结构如下：

```go
    select {
    case <-chan1:
        // 如果chan1成功读到数据，则进行该case处理语句
    case chan2 <- 1:
        // 如果成功向chan2写入数据，则进行该case处理语句
    default:
        // 如果上面都没有成功，则进入default处理流程
    }
```

在一个select语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句。

如果其中的任意一语句可以继续执行(即没有被阻塞)，那么就从那些可以执行的语句中任意选择一条来使用。

如果没有任意一条语句可以执行(即所有的通道都被阻塞)，那么有两种可能的情况：

- 如果给出了default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复。
- 如果没有default语句，那么select语句将被阻塞，直到至少有一个通信可以进行下去。

通过select实现斐波那契数列

```go
package main
 
import (
    "fmt"
)
 
//ch只写，quit只读
func fibonacci(ch chan<- int, quit <-chan bool) {
    x, y := 1, 1
    for {
        //监听channel数据的流动
        select {
        case ch <- x:
            x, y = y, x+y
        case flag := <-quit:
            fmt.Println("flag = ", flag)
            return
        }
    }
}
 
func main() {
    ch := make(chan int)    //数字通信
    quit := make(chan bool) //程序是否结束
 
    //消费者，从channel读取内容
    //新建协程
    go func() {
        for i := 0; i < 8; i++ {
            num := <-ch
            fmt.Println(num)
        }
        //可以停止
        quit <- true
    }() //别忘了()
 
    //生产者，产生数字，写入channel
    fibonacci(ch, quit)
 
}
执行结果：
1    // x =1, y=1,
1
2    //  x=1, y=x+y
3
5
8
13
21
flag =  true
```



#### 超时

有时候会出现goroutine阻塞的情况，那么我们如何避免整个程序进入阻塞的情况呢？我们可以利用select来设置超时，通过如下的方式实现：

```go
package main
 
import (
    "fmt"
    "time"
)
 
func main() {
    ch := make(chan int)
    quit := make(chan bool)
 
    //新开一个协程
    go func() {
        for {
            select {
            case num := <-ch:
                fmt.Println("num = ", num)
            case <-time.After(3 * time.Second):
                fmt.Println("超时")
                quit <- true
            }
        }
 
    }() //别忘了()
 
    for i := 0; i < 5; i++ {
        ch <- i
        time.Sleep(time.Second)
    }
 
    <-quit
    fmt.Println("程序结束")
 
}
执行结果：
num =  0
num =  1
num =  2
num =  3
num =  4
超时
程序结束
```



## 网络概述、socket编程

### 网络概述

#### 网络协议

从应用的角度出发，协议可理解为“规则”，是数据传输和数据的解释的规则。

假设，A、B双方欲传输文件。规定：


第一次，传输文件名，接收方接收到文件名，应答OK给传输方；
第二次，发送文件的尺寸，接收方接收到该数据再次应答一个OK；
第三次，传输文件内容。同样，接收方接收数据完成后应答OK表示文件内容接收成功。


由此，无论A、B之间传递何种文件，都是通过三次数据传输来完成。A、B之间形成了一个最简单的数据传输规则。双方都按此规则发送、接收数据。A、B之间达成的这个相互遵守的规则即为协议。

这种仅在A、B之间被遵守的协议称之为原始协议。

当此协议被更多的人采用，不断的增加、改进、维护、完善。最终形成一个稳定的、完整的文件传输协议，被广泛应用于各种文件传输过程中。该协议就成为一个标准协议。最早的ftp协议就是由此衍生而来。

#### 分层模型

##### 网络分层架构

为了减少协议设计的复杂性，大多数网络模型均采用分层的方式来组织。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。**每一层利用下一层提供的服务来为上一层提供服务，本层服务的实现细节对上层屏蔽。**

![](E:\notebook\golang\golang语言基础\doc_pic\网络分层架构.png)

越下面的层，越靠近硬件；越上面的层，越靠近用户。至于每一层叫什么名字，其实并不重要（面试的时候，面试官可能会问每一层的名字）。只需要知道，互联网分成若干层即可。

1)物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。

2)数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1

3)网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。

4)传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。

5)会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。

6)表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。

7)应用层：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。

##### 层与协议

每一层都是为了完成一种功能，为了实现这些功能，就需要大家都遵守共同的规则。大家都遵守这规则，就叫做“协议”（protocol）。

网络的每一层，都定义了很多协议。这些协议的总称，叫“TCP/IP协议”。TCP/IP协议是一个大家族，不仅仅只有TCP和IP协议，它还包括其它的协议，如下图： 
![](E:\notebook\golang\golang语言基础\doc_pic\层与协议.png)

TCP(Transmission Control Protocol)传输控制协议

IP(Internet Protocol)网际协议 

UDP(User Datagram Protocol)用户数据报协议

ICMP(Internet Control Message Protocol)互联网控制信息协议

SMTP(Simple Mail Transfer Protocol)简单邮件传输协议

 SNMP(Simple Network manage Protocol)简单网络管理协议

 FTP(File Transfer Protocol)文件传输协议

 ARP(Address Resolation Protocol)地址解析协议

##### 每层协议的功能

![](E:\notebook\golang\golang语言基础\doc_pic\每层协议的功能.png)

1） 链路层

**以太网规定，连入网络的所有设备，都必须具有“网卡”接口**。数据包必须是从一块网卡，传送到另一块网卡。通过网卡能够使不同的计算机之间连接，从而完成数据通信等功能。网卡的地址——MAC 地址，就是数据包的物理发送地址和物理接收地址。

2） 网络层

网络层的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做“网络地址”，这是我们平时所说的IP地址。这个IP地址好比我们的手机号码，通过手机号码可以得到用户所在的归属地。

网络地址帮助我们确定计算机所在的子网络，MAC 地址则将数据包送到该子网络中的目标网卡。网络层协议包含的主要信息是源IP和目的IP。

于是，“网络层”出现以后，每台计算机有了两种地址，一种是 MAC 地址，另一种是网络地址。两种地址之间没有任何联系，MAC 地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。

网络地址帮助我们确定计算机所在的子网络，MAC 地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理 MAC 地址。


3）传输层

当我们一边聊QQ，一边聊微信，当一个数据包从互联网上发来的时候，我们怎么知道，它是来自QQ的内容，还是来自微信的内容？

也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做“端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。

端口特点：

对于同一个端口，在不同系统中对应着不同的进程
对于同一个系统，一个端口只能被一个进程拥有

4）应用层

应用程序收到“传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。“应用层”的作用，就是规定应用程序的数据格式。

#### 网络通信条件

- 网卡，mac地址（不需要用户处理）  arp --->通过IP找mac
- 逻辑地址，ip地址（需要用户指定）  ---> 为了确定那个电脑接收
- 端口  --->为了确定那个程序接收
- 同一个系统，一个程序只能绑定一个端口
- 不同系统，同一端口对应程序可能不一样

### Socket编程

#### 什么是socket

Socket起源于Unix，而Unix基本哲学之一就是“一切皆文件”，都可以用“打开open –> 读写write/read –> 关闭close”模式来操作。Socket就是该模式的一个实现，网络的Socket数据传输是一种特殊的I/O，Socket也是一种文件描述符。Socket也具有一个类似于打开文件的函数调用：Socket()，该函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。

常用的Socket类型有两种：流式Socket（SOCK_STREAM）和数据报式Socket（SOCK_DGRAM）。流式是一种面向连接的Socket，针对于面向连接的TCP服务应用；数据报式Socket是一种无连接的Socket，对应于无连接的UDP服务应用。

#### TCP的C/S架构

![](E:\notebook\golang\golang语言基础\doc_pic\socket架构.png)

#### 示例程序

##### 服务器代码

```go
package main
 
import (
    "fmt"
    "net"
)
 
func main() {
    //监听
    listener, err := net.Listen("tcp", "127.0.0.1:8000")
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
 
    defer listener.Close()
 
    //阻塞等待用户链接
    conn, err := listener.Accept()
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
 
    //接收用户的请求
    buf := make([]byte, 1024) //1024大小的缓冲区
    n, err1 := conn.Read(buf)
    if err1 != nil {
        fmt.Println("err1 = ", err1)
        return
    }
 
    fmt.Println("buf = ", string(buf[:n]))
 
    defer conn.Close() //关闭当前用户链接
}
```



##### 客户端代码

```go
package main
 
import (
    "fmt"
    "net"
)
 
func main() {
    //主动连接服务器
    conn, err := net.Dial("tcp", "127.0.0.1:8000")
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
 
    defer conn.Close()
 
    //发送数据
    conn.Write([]byte("are you ok?"))
 
}
```



##### 运行结果

先启动服务端：go run tcp_server.go

```shell
`D:\GoFiles\src\hello_01>``go` `run tcp_server.``go``buf =  are u ok?`
```

再启动客户端：go run tcp_client.go

#### 简单版并发服务器

##### 服务器

```go
package main
 
import (
    "fmt"
    "net"
    "strings"
)
 
//处理用户请求
func HandleConn(conn net.Conn) {
    //函数调用完毕，自动关闭conn
    defer conn.Close()
 
    //获取客户端的网络地址信息
    addr := conn.RemoteAddr().String()
    fmt.Println(addr, " conncet sucessful")
 
    buf := make([]byte, 2048)
 
    for {
        //读取用户数据
        n, err := conn.Read(buf)
        if err != nil {
            fmt.Println("err = ", err)
            return
        }
        fmt.Printf("[%s]: %s\n", addr, string(buf[:n]))
        fmt.Println("len = ", len(string(buf[:n])))
 
        //if "exit" == string(buf[:n-1]) { //nc测试
        if "exit" == string(buf[:n-2]) { //自己写的客户端测试, 发送时，多了2个字符, "\r\n"
            fmt.Println(addr, " exit")
            return
        }
 
        //把数据转换为大写，再给用户发送
        conn.Write([]byte(strings.ToUpper(string(buf[:n]))))
    }
 
}
 
func main() {
    //监听
    listener, err := net.Listen("tcp", "127.0.0.1:8000")
    if err != nil {
        fmt.Println("err = ", err)
        return
    }
 
    defer listener.Close()
 
    //接收多个用户
    for {
        conn, err := listener.Accept()
        if err != nil {
            fmt.Println("err = ", err)
            return
        }
 
        //处理用户请求, 新建一个协程
        go HandleConn(conn)
    }
 
}
```

##### 客户端

````go
package main
 
import (
    "fmt"
    "net"
    "os"
)
 
func main() {
    //主动连接服务器
    conn, err := net.Dial("tcp", "127.0.0.1:8000")
    if err != nil {
        fmt.Println("net.Dial err = ", err)
        return
    }
 
    //main调用完毕，关闭连接
    defer conn.Close()
 
    go func() {
        //从键盘输入内容，给服务器发送内容
        str := make([]byte, 1024)
        for {
            n, err := os.Stdin.Read(str) //从键盘读取内容， 放在str
            if err != nil {
                fmt.Println("os.Stdin. err = ", err)
                return
            }
 
            //把输入的内容给服务器发送
            conn.Write(str[:n])
        }
    }()
 
    //接收服务器回复的数据
    //切片缓冲
    buf := make([]byte, 1024)
    for {
        n, err := conn.Read(buf) //接收服务器的请求
        if err != nil {
            fmt.Println("conn.Read err = ", err)
            return
        }
        fmt.Println(string(buf[:n])) //打印接收到的内容, 转换为字符串再打印
    }
}
````

##### 运行结果

​	![](E:\notebook\golang\golang语言基础\doc_pic\简单并发服务器结果.png)

## HTTP编程

### 概述

#### Web工作方式

#### HTTP协议

#### 地址（URL）

### HTTP报文浅析

#### 请求报文格式

1）测试代码

2）请求报文格式说明

 